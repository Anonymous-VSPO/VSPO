{"class": "Datatype Specification Language Representation", "description": "Datatype Specification Language Representation is a subclass of representation, characterized by the property that it represents at least one datatype. This class encompasses languages or symbolic forms specifically designed to define, describe, or model datatypes through a formal representation. Every individual in this class must be associated with the representation of some datatype, reflecting its role in specifying datatype structure or characteristics."}
{"class": "list specification", "description": "list specification is defined as a subclass of specification. This means all instances of list specification are also considered specifications. No additional disjointness, property restrictions, or further descriptive details are specified, so the class serves as a specialization of the general concept of specification for use cases where differentiation among specification types is needed."}
{"class": "value space", "description": "value space is defined as a subclass of specification. This means that every value space is a type of specification, inheriting the general characteristics of specification while representing a distinct concept within that category. No additional distinguishing features or restrictions are asserted by the current axioms."}
{"class": "tag-value list", "description": "tag-value list is defined as a subclass of specification, indicating that it represents a specific kind of specification. This class formalizes entities that provide information or structure through a collection of tags and their corresponding values, typically used to encode attribute data in a structured format."}
{"class": "procedure-paremeter declaration", "description": "procedure-parameter declaration is defined as a subclass of specification. All instances of this class must include at least one member with the type parameter and at least one member with the type direction, as specified by the property restrictions. This class formally represents declarations in a procedure that specify the required parameters and their directions, ensuring that every procedure-parameter declaration comprehensively describes its involved parameters and their input/output directions."}
{"class": "direction", "description": "direction is defined as a subclass of specification. This means that every direction is a specific type of specification, and it inherits all characteristics and properties applicable to specifications in the ontology. No further constraints or descriptions have been provided, so the class serves as a general categorization for directions under the broader concept of specifications."}
{"class": "return-parameter specification", "description": "return-parameter specification is a subclass of specification, characterized by having at least one member that is a datatype and at least one associated identifier that qualifies as a parameter identifier. This formalization ensures that every return-parameter specification includes a datatype value and a means of uniquely identifying the parameter, which is essential for describing properties of parameters returned by functions or methods in structured data or APIs."}
{"class": "defined generator parameter", "description": "defined generator parameter is a subclass of specification, meaning it inherits all characteristics of the specification class. Additionally, any individual in this class must possess at least one identifier, specified through the property has_identifier and linked to a parameter identifier. This definition ensures that every defined generator parameter instance is uniquely identified in the context of specifications."}
{"class": "select-item specification", "description": "select-item specification is defined as a subclass of specification. This indicates that every select-item specification is a type of specification, inheriting all characteristics of the parent class, with no additional restrictions or distinctions provided in the current formalization. No further disjointness or property constraints are specified."}
{"class": "datatype generator", "description": "datatype generator is defined as a subclass of directive information entity. This indicates that any datatype generator inherits all structural and semantic characteristics of directive information entities, typically representing an information construct that prescribes or instructs the generation of datatypes. No further property restrictions or disjointness axioms are specified."}
{"class": "characterizing operation", "description": "characterizing operation is a subclass of directive information entity. It refers to the set of operations that, either performed on or producing values of a datatype, distinguish that datatype from others with otherwise identical value spaces except potentially for symbol substitution. This class is used to formally capture the unique operational behaviors that define and differentiate datatypes in an information system."}
{"class": "data representational model", "description": "data representational model is defined as a subclass of directive information entity. This means any instance of a data representational model is also an instance of directive information entity, inheriting all its properties and characteristics. The class is intended to capture entities that provide structured directives on how data is to be represented or organized."}
{"class": "datatype role", "description": "datatype role is defined as a subclass of role, with the property restriction that it must be the role_of at least one datatype. This means every instance of datatype role is associated with, and specifically plays a role in the context of, some datatype."}
{"class": "excluding subtype generator", "description": "excluding subtype generator is defined as a subclass of subtype generator, with the added restriction that it must have at least one member specified by the has_member property, where the member is of the type select-list. This means every instance of excluding subtype generator must be associated with at least one select-list through the has_member property, providing a mechanism for selecting or excluding specific subtypes via a list-based criteria."}
{"class": "explicit subtype generator", "description": "explicit subtype generator is defined as a subclass of subtype generator, meaning every explicit subtype generator is also a subtype generator. No further restrictions or characteristics are specified by the current axioms or descriptions."}
{"class": "extending subtype generator", "description": "extending subtype generator is defined as a subclass of subtype generator. It is characterized by the property restriction that every instance must have at least one member from an extended-value-list. This ensures that individuals of this class are subtype generators specifically connected to one or more extended value lists, reflecting their extended generative capability."}
{"class": "range subtype generator", "description": "range subtype generator is defined as a subclass of subtype generator. Members of this class are characterized by the existence of at least one member related via the has_member property that is an instance of range. This formalization ensures that any range subtype generator must be associated with at least one range through the has_member relationship."}
{"class": "selection subtype generator", "description": "selection subtype generator is defined as a subclass of subtype generator. Any instance of this class must have at least one member that is a select-list, enforced by the property restriction [has_member some select-list]. This ensures that selection subtype generators are specifically characterized by their association with select-list members, distinguishing them from other subtype generators."}
{"class": "size subtype generator", "description": "size subtype generator is a subclass of subtype generator whose members are characterized by necessarily having at least one associated member of type size. This ensures that any instance of size subtype generator must be linked to one or more sizes, establishing its role in creating subtypes specifically based on size distinctions."}
{"class": "natural number", "description": "natural number is defined as a subclass of defined datatype, indicating that it represents a specific kind of datatype with well-established properties. Natural numbers typically include non-negative integers (0, 1, 2, ...), and are formally distinguished from other datatypes by their discrete, countable nature. This classification ensures that any individual of the class natural number is treated as a clearly defined, foundational numeric datatype."}
{"class": "modulo", "description": "modulo is defined as a subclass of defined datatype, indicating that it represents a specifically characterized datatype within the ontology. No further domain-specific properties or restrictions are specified for this class based on the current axiom."}
{"class": "bit", "description": "bit is defined as a subclass of defined datatype, indicating that it represents a specific, well-defined data value within the ontology. As a data-oriented class, bit inherits all characteristics of defined datatypes but is further specialized for contexts where only binary or distinctly specified data values are relevant."}
{"class": "bit string", "description": "bit string is defined as a subclass of defined datatype, representing a specific type of datatype whose values consist of sequences of bits. This classification situates bit string within the hierarchy of datatypes and indicates its specialization for encoding data as ordered collections of binary digits."}
{"class": "character string", "description": "character string is defined as a subclass of defined datatype. This means any instance of character string is also recognized as a defined datatype, typically representing a sequence of characters used to encode textual information."}
{"class": "time interval", "description": "time interval is defined as a subclass of defined datatype, indicating that it represents a structured data value within the ontology. As a specialized datatype, time interval refers to a span or duration of time, inheriting all properties and constraints applicable to defined datatypes."}
{"class": "octet", "description": "octet is defined as a subclass of defined datatype, establishing it as a specific type of datatype within the ontology. This formalization indicates that any instance of octet must satisfy all constraints applicable to defined datatype, but provides no further restrictions or additional properties beyond this classification."}
{"class": "octet string", "description": "octet string is defined as a subclass of defined datatype. This means that octet string represents a specific type of datatype, though its precise structure and constraints are not further elaborated in the current axioms. Members of this class inherit all characteristics of defined datatype."}
{"class": "private", "description": "private is defined as a subclass of defined datatype, indicating that it represents a specific kind of datatype within the ontology. No additional restrictions or disjointness axioms are specified, so its primary characteristic is its hierarchical relationship as a more specialized form of defined datatype."}
{"class": "object identifier", "description": "object identifier is defined as a subclass of defined datatype. This means that every object identifier is a specific type of defined datatype, typically used to uniquely distinguish individual entities or objects within a system or dataset."}
{"class": "non-directed labeled graph datatype", "description": "non-directed labeled graph datatype is defined as a subclass of defined datatype. Any member of this class must include at least one non-directed labeled graph generator and at least one graph aggregate component as elements (as specified by the has_member property). This formalization captures datatypes representing non-directed labeled graphs constructed or characterized by these required components."}
{"class": "labeled graph datatype", "description": "labeled graph datatype is defined as a subclass of defined datatype, with the additional restriction that it must have at least one member produced by a directed labeled graph datatype generator. This means every labeled graph datatype is necessarily structured to include elements generated from a mechanism or process that produces directed labeled graph datatypes, distinguishing it from other defined datatypes that may lack this property."}
{"class": "stack", "description": "stack is defined as a subclass of defined generator. This means every stack is a type of defined generator, inheriting all characteristics associated with defined generators. No additional property restrictions, disjointness, or equivalence assertions are specified. This class is intended to capture entities that possess the structural or functional traits of defined generators, refined specifically as stacks."}
{"class": "tree", "description": "tree is defined as a subclass of defined generator. This indicates that any instance of tree is considered a type of defined generator, inheriting all properties and restrictions from that superclass. No additional property restrictions or disjointness axioms are specified for this class."}
{"class": "optional", "description": "optional is defined as a subclass of defined generator, indicating that every optional is a type of defined generator. This means all individuals classified as optional inherit the properties and restrictions of defined generator, but may have further distinguishing features or constraints specified elsewhere. There are no additional axioms or asserted properties currently restricting the class further."}
{"class": "directed labeled graph datatype generator", "description": "directed labeled graph datatype generator is a subclass of defined generator. This class represents generators that are specifically designed to produce directed labeled graph datatypes, inheriting the general properties of defined generators while specializing in the context of graph structures with directed edges and labeled nodes or connections."}
{"class": "non-directed labeled graph generator", "description": "non-directed labeled graph generator is defined as a subclass of defined generator. This means every non-directed labeled graph generator is a type of defined generator, inheriting its general properties. The class represents entities that produce non-directed graphs in which nodes and/or edges are assigned labels, but with no explicit directionality imposed on the connections."}
{"class": "vector generator", "description": "vector generator is a subclass of defined generator, indicating that every vector generator is also a defined generator. No additional constraints or unique characteristics have been specified beyond this hierarchical relationship. The purpose and specific properties of vector generator are inherited from defined generator."}
{"class": "array generator", "description": "array generator is a subclass of homogenous aggregate generator and is explicitly disjoint with homogenous aggregate generator with variable size, ensuring that an instance cannot belong to both classes simultaneously. Members of the array generator class are characterized by possessing certain qualities: they are unordered aggregates, have a fixed size, can be multi-dimensional, allow index-based access, and may contain non-unique values. This combination of properties formally describes the essential characteristics of array generators, distinguishing them from other types of homogenous aggregate generators."}
{"class": "homogenous aggregate generator with variable size", "description": "homogenous aggregate generator with variable size is a subclass of homogenous aggregate generator. Members of this class are characterized by possessing at least one quality of having variable size, as specified by the 'has_quality some variable size' restriction. This formalization ensures that any individual classified under this class must be a homogenous aggregate generator that exhibits variability in size as one of its defining qualities."}
{"class": "bag generator", "description": "bag generator is defined as a subclass of homogenous unordered aggregate generator with variable size and is explicitly disjoint with set generator, indicating that an individual cannot be both a bag generator and a set generator. Members of this class are characterized by generating collections where items may have non-unique values (duplicates are permitted) and the way elements are accessed is implementation dependent. This ensures that bag generators support variable-sized, unordered aggregates allowing repeated elements, with element access properties not universally specified."}
{"class": "set generator", "description": "set generator is defined as a subclass of homogenous unordered aggregate generator with variable size. Members of this class are characterized by having the qualities of access by value and containing unique values. This means that each instance generates aggregates where elements are both accessed directly by their value (rather than by reference or position) and all elements within any generated aggregate are unique, with no duplicates permitted."}
{"class": "class generator", "description": "class generator is defined as a subclass of heterogenous aggregate generator and is explicitly disjoint with both record generator and table generator, meaning an individual cannot belong to more than one of these classes simultaneously. Members of the class generator are characterized by having the following qualities: key access, unordered aggregate structure, non-unique values, one-dimensional organization, and fixed size. These properties collectively define class generator as a type of aggregate generator that supports key-based, unordered collections with potentially repeated values, all arranged in a single dimension with a fixed number of elements."}
{"class": "record generator", "description": "record generator is defined as a subclass of heterogenous aggregate generator and is explicitly disjoint with table datatype, ensuring that an individual cannot be both a record generator and a table datatype. Members of the record generator class must possess several qualities: they have a fixed size, are one-dimensional, form an unordered aggregate, support key access, and can contain non-unique values. This formalization captures the characteristic structure of a record generator, emphasizing its fixed, one-dimensional, unordered nature with keyed access and allowance for repeated values."}
{"class": "table generator", "description": "table generator is defined as a subclass of heterogenous aggregate generator and is characterized by several property restrictions: it must possess the qualities of having non-unique values, variable size, being an unordered aggregate, and being two dimensional. These constraints specify that any instance of table generator produces or represents a two-dimensional collection of items where elements may repeat, the number of items can vary, the arrangement lacks a specific sequence, and multiple types of elements (heterogeneity) are permitted."}
{"class": "sequence generator", "description": "sequence generator is defined as a subclass of homogenous aggregate generator with variable size, and is explicitly disjoint from homogenous unordered aggregate generator with variable size\u2014meaning an individual cannot belong to both classes at once. Members of the sequence generator class are characterized by possessing certain qualities: they generate aggregates with non-unique values, maintain an ordered structure, and support position-based access to elements. These constraints formally specify that sequence generators create ordered collections (or aggregates) where repeated values are permissible and positional referencing is available, distinguishing them from unordered aggregate generators."}
{"class": "homogenous unordered aggregate generator with variable size", "description": "homogenous unordered aggregate generator with variable size is a subclass of homogenous aggregate generator with variable size and is defined as being equivalent to either a bag generator or a set generator. Members of this class are characterized by having the quality of generating unordered aggregates, reflecting that the elements produced do not have intrinsic order. This ontology definition ensures that any homogenous unordered aggregate generator with variable size behaves as a variable-sized aggregate generator whose items are homogeneous and unordered, aligning with the behaviors of both bag generators and set generators."}
{"class": "choice generator", "description": "choice generator is defined as a subclass of non-aggregate generator. Members of this class are further characterized by the property that they are associated with at least one choice datatype, as expressed by the restriction [is_member_of some choice datatype]. This means any individual classified as a choice generator must participate in or be a member of a choice datatype, distinguishing them from other forms of non-aggregate generators."}
{"class": "pointer generator", "description": "pointer generator is defined as a subclass of non-aggregate generator. Every instance of pointer generator must be a member of some pointer datatype, indicating that this class is characterized by its association with pointer datatypes. This structure ensures that all pointer generators participate specifically within the context of pointer datatypes and inherit the properties of non-aggregate generators."}
{"class": "procedure generator", "description": "procedure generator is defined as a subclass of non-aggregate generator. This means that every procedure generator is a specific type of non-aggregate generator, inheriting all properties and constraints applicable to non-aggregate generators. No further restrictions or characteristics are provided by the current axioms."}
{"class": "table datatype", "description": "table datatype is defined as a subclass of heterogenous aggregate datatype, and is explicitly disjoint with record (tuple) datatype, indicating that no instance can simultaneously belong to both classes. Members of the table datatype class are characterized by the following: they always have at least one table generator and a field-list as members; possess the qualities of being exact and non-numeric; and support several specific operations, including IsEmpty, MapToBag, Insert, Select, MapToTable, Delete, Fetch, and Serialize. This formalization distinguishes table datatype from other aggregate types, ensuring that it is uniquely identified by its supported operations, membership requirements, and data qualities."}
{"class": "class datatype", "description": "class datatype is a subclass of heterogenous aggregate datatype and is explicitly disjoint with record (tuple) datatype, ensuring that no individual can belong to both classes. Members of class datatype are characterized by the following property restrictions: they must have operations such as AttributeSelect, AttributeReplace, and Equal (each operating on class), must include members such as a class generator and an attribute-list, and must exhibit the qualities of being non-ordered and non-numeric. This formalization distinguishes class datatypes from other aggregates (like records) by their operations and inherent qualities."}
{"class": "record (tuple) datatype", "description": "record (tuple) datatype is defined as a subclass of heterogenous aggregate datatype, representing a collection of fields that may be of differing types. It is synonymous with \"tuple datatype.\" Members of this class possess non-numeric, non-ordered, and exact qualities, supporting operations such as field selection (FieldSelect:record), field replacement (FieldReplace:record), and equality checking (Equal:record). Additionally, each record (tuple) must include a member that is a record generator and a member that is a field-list. This class formalizes the concept of records or tuples typically used to model structured, fixed-length data with heterogeneous types."}
{"class": "attribute identifier", "description": "attribute identifier is defined as a subclass of identifier, indicating that every attribute identifier is an identifier with a specific role in distinguishing or denoting attributes within a system. This class inherits all properties associated with identifiers, but specializes them for use in the identification of attributes. No further property restrictions or disjointness axioms are specified."}
{"class": "parameter identifier", "description": "parameter identifier is a subclass of identifier. This means every parameter identifier is an identifier, inheriting all its properties and characteristics, but is specifically used to denote or reference parameters (such as in functions or methods). The axiom ensures that all parameter identifiers are included within the broader category of identifiers."}
{"class": "enumerated-value identifier", "description": "enumerated-value identifier is a subclass of identifier, characterized by the restriction that its values must be associated (through the has-value property) with at least one literal value (rdfs:Literal). This formalization ensures that every enumerated-value identifier refers explicitly to a concrete literal value, distinguishing it from other identifiers that may not be directly tied to literal data."}
{"class": "discrete-value identifier", "description": "discrete-value identifier is a subclass of identifier whose instances are constrained to have at least one associated value specified as an rdfs:Literal. This means that every discrete-value identifier must be linked to some literal value (such as a string, number, or date), formalizing the notion of identifiers that represent or encode discrete, literal data."}
{"class": "extended-value identifier", "description": "extended-value identifier is defined as a subclass of identifier. Members of this class inherit all characteristics of identifiers, serving the purpose of uniquely distinguishing entities, but are further specified as relating to extended-value contexts. No additional property restrictions or disjointness axioms are currently asserted for this class."}
{"class": "character-set identifier", "description": "character-set identifier is defined as a subclass of identifier. This means every character-set identifier is an identifier, but with a more specific role, typically used to uniquely represent or designate different character sets within a system or context. There are no further axioms or restrictions specified for this class."}
{"class": "field identifier", "description": "field identifier is defined as a subclass of identifier. Members of this class inherit all characteristics of identifiers, specifically representing identifiers that are associated with fields. This formalization ensures field identifiers are treated as a specialized type of identifier, typically used to uniquely reference or denote fields within a given context or system."}
{"class": "aggregate imposed ordering", "description": "aggregate imposed ordering is defined as a subclass of aggregate generator property and is disjoint with aggregate-imposed identifier uniqueness, homogenity, aggregate size, uniqueness, component mandatoriness, structurness, recursiveness, and access type\u2014ensuring that no individual can simultaneously belong to these disjoint classes. It is equivalent to the union of ordered aggregate and unordered aggregate, indicating that every aggregate imposed ordering instance must be either an ordered aggregate or an unordered aggregate. This class captures the property by which an aggregate specifies an ordering\u2014imposed or absent\u2014over its components, distinguishing it from other aggregate generator properties."}
{"class": "aggregate-imposed identifier uniqueness", "description": "aggregate-imposed identifier uniqueness is a subclass of aggregate generator property, and is explicitly disjoint with classes such as homogenity, aggregate size, uniqueness, component mandatoriness, structurness, recursiveness, and access type, ensuring mutual exclusivity with these notions. It is defined equivalently as a situation where an identifier may or may not be unique (identifier not unique or identifier unique), capturing precisely those cases where the uniqueness of identifiers is determined at the aggregate level rather than being strictly enforced or absent."}
{"class": "homogenity", "description": "homogenity is defined as a subclass of aggregate generator property and is explicitly disjoint with the classes aggregate size, uniqueness, component mandatoriness, structurness, recursiveness, and access type, ensuring that no individual can simultaneously belong to these. It is also equivalent to the union of homogenous or heterogenous, indicating that any instance of homogenity must be categorized as either homogenous or heterogenous with respect to an aggregate generator property."}
{"class": "agregate size", "description": "aggregate size is a subclass of aggregate generator property and is formally equivalent to either fixed size or variable size, indicating that it refers to the characteristic of an aggregate having a specified or changeable quantity of components. It is explicitly disjoint with uniqueness, component mandatoriness, structurness, recursiveness, and access type, ensuring that no instance can simultaneously belong to these classes. This class is used to describe whether an aggregate maintains a constant number of elements or allows its size to vary."}
{"class": "uniqueness", "description": "uniqueness is defined as a subclass of aggregate generator property and is explicitly disjoint from component mandatoriness, structurness, recursiveness, and access type, meaning no entity can be an instance of both uniqueness and any of these disjoint classes simultaneously. It is equivalent to the presence of either unique values or non-unique values, capturing the property of whether values are distinct or may repeat within an aggregate context. This definition formalizes how uniqueness characterizes and distinguishes value patterns in aggregate generator properties."}
{"class": "component mandatoriness", "description": "component mandatoriness is defined as a subclass of aggregate generator property and is explicitly disjoint with structurness, recursiveness, and access type, ensuring no overlap among individuals of these classes. It is equivalent to the union of component mandatory and component non-mandatory, meaning every instance of component mandatoriness must be either component mandatory or component non-mandatory. This class categorizes aggregate generator properties by specifying whether a component is mandatory or not."}
{"class": "structurness", "description": "structurness is defined as a subclass of aggregate generator property and is disjoint with both recursiveness and access type, indicating that no entity can simultaneously belong to structurness and either of these disjoint classes. Additionally, structurness is formally equivalent to the union of structured, unstructured, or semi-structured, meaning any entity that is classified as one of these three types is also considered an instance of structurness. This definition situates structurness as a categorical property that distinguishes types of structural organization within aggregate generator properties."}
{"class": "recursiveness", "description": "recursiveness is defined as a subclass of aggregate generator property, indicating it is a specific kind of property related to aggregate generators. It is explicitly disjoint with access type, meaning no entity can simultaneously be both an access type and exhibit recursiveness. Additionally, recursiveness is formally equivalent to either recursive or non-recursive, fully covering both possibilities as mutually exclusive characteristics within this context."}
{"class": "access type", "description": "access type is defined as a subclass of aggregate generator property and is equivalent to the union of direct access property and indirect access property. This means that any instance of access type must be either a direct access property or an indirect access property, and no other properties qualify as access types outside of this definition."}
{"class": "dimensionality", "description": "dimensionality is defined as a subclass of aggregate generator property, characterizing properties related to the generation or structure of aggregates. It is equivalent to the union of one dimensional, two dimensional, or multi dimensional classes, meaning that an instance of dimensionality must fall into one of these specific categories. This ensures that any property classified as dimensionality pertains to aggregates with exactly one, two, or multiple dimensions."}
{"class": "primitive datatype", "description": "primitive datatype is a subclass of datatype, and is explicitly disjoint from both generated datatype and defined datatype, ensuring that no individual can simultaneously belong to these classes. Members of primitive datatype are characterized by the requirement that they possess at least one quality related to equality (expressed as having some has_quality relationship to equality). This formalization captures the basic, irreducible nature of primitive datatypes, differentiating them from those that are constructed or defined based on other rules."}
{"class": "generated datatype", "description": "generated datatype is defined as a subclass of datatype and is explicitly disjoint with defined datatype, meaning no individual can be both a generated datatype and a defined datatype. Members of this class are further constrained by the property restriction that each generated datatype must have at least one member (has_member) that is a generated datatype generator. This formalization distinguishes generated datatypes from defined datatypes and ensures their association with specific generating mechanisms."}
{"class": "defined datatype", "description": "defined datatype is a subclass of datatype. It is characterized by having some members that are defined generators and some members that are defined datatype parameter-lists. This means that any defined datatype instance must be associated with at least one defined generator and at least one defined datatype parameter-list via the has_member property."}
{"class": "defined datatype parameter", "description": "defined datatype parameter is a subclass of datatype role, representing a parameter that is specifically associated with datatypes. Any member of this class must have an identifier (i.e., satisfy the has_identifier property with respect to some parameter identifier), must be a member of a defined datatype parameter-list, and must play the role_of some datatype. This formalization ensures that a defined datatype parameter is always linked to a datatype and properly identified within a parameter list structure."}
{"class": "field component", "description": "field component is defined as a subclass of datatype role. It is further characterized by two property restrictions: every field component must participate in the role_of relationship with at least one datatype, and must have at least one identifier of type field identifier. This formalization ensures that field components are specifically associated with datatypes and are uniquely identifiable within the ontology."}
{"class": "tag-type", "description": "tag-type is defined as a subclass of datatype role. Every instance of tag-type must serve as the role_of at least one datatype, meaning that each tag-type is associated with one or more datatype instances through the role_of property. This establishes tag-type as a specific role related to datatypes within the ontology."}
{"class": "alternative-type", "description": "alternative-type is defined as a subclass of datatype role. Instances of this class must be the role of at least one datatype and must also be a member of some alternative component. This formalization ensures that alternative-type represents a specialized datatype role that is contextually linked both to specific datatypes and to alternative components."}
{"class": "alternative component", "description": "alternative component is defined as a subclass of datatype role, characterized by the requirement that it must have at least one member that is a tag-value list and at least one member that is an alternative-type. This means every instance of alternative component is associated with at least one tag-value list and one alternative-type via the has_member property, formalizing its structure as a composition of these elements."}
{"class": "pointer-element-type", "description": "pointer-element-type is a subclass of datatype role, characterized by the restriction that it must be a role of some datatype. This means that any instance of pointer-element-type is specifically associated with at least one datatype through the \"role_of\" property, formalizing its function as a role connecting to datatypes within the ontology."}
{"class": "parameter", "description": "parameter is defined as a subclass of datatype role, representing entities that serve a specific function within a datatype context. Each parameter must be associated with some datatype (via the role_of property) and must have an identifier that is a member of the parameter identifier class. This ensures that every parameter is explicitly linked to the datatype it qualifies and is uniquely identified within the system."}
{"class": "index-type", "description": "index-type is a subclass of datatype role, characterized by specific property restrictions. Any instance of index-type must have as members both an index upperbound and an index lowerbound, indicating the range of allowable index values. Additionally, index-type instances are members of an index-type list and are associated, via the role_of property, with some datatype. This formalization ensures that index-type serves as a role connecting data types to index value ranges, organized within relevant index-type lists."}
{"class": "base type", "description": "base type is defined as a subclass of datatype role. Any instance of base type must fulfill two key conditions: it must have a relationship 'role_of' to at least one datatype, and it must be a member of at least one complex datatype\u2014specifically, an array datatype, sequence datatype, bag datatype, set datatype, or extended datatype. This formalization ensures that base type instances are foundational datatypes actively participating in, and forming members of, various structured or composite datatypes."}
{"class": "attribute component", "description": "attribute component is defined as a subclass of datatype role, meaning each attribute component is a specific kind of datatype role. Additionally, attribute component instances are required to be associated with at least one attribute identifier through the has_identifier property. This ensures that every attribute component is uniquely identified by an attribute identifier."}
{"class": "real field-list", "description": "real field-list is defined as a subclass of field-list, explicitly disjoint from boolean field-list and discrete field-list, ensuring no overlap in membership between these types. Members of real field-list are characterized by the property that they contain at least one real field component as a member. This formalization guarantees that any real field-list includes real-valued field components and cannot simultaneously be considered a boolean or discrete field-list."}
{"class": "boolean field-list", "description": "boolean field-list is a subclass of field-list and is explicitly disjoint with discrete field-list, ensuring no instance can be both a boolean field-list and a discrete field-list. Every boolean field-list must include at least one member that is a boolean field component, establishing that the primary distinguishing feature of this class is the presence of boolean field components among its members."}
{"class": "discrete field-list", "description": "discrete field-list is a subclass of field-list, defined by the restriction that its members must include at least one discrete field component. This ensures that every instance of discrete field-list contains some element that is characterized as a discrete field component."}
{"class": "primitive field-list", "description": "primitive field-list is defined as a subclass of field-list, with the restriction that it must have at least one member that is a primitive field component. This means that every instance of primitive field-list comprises a collection of fields where at least one member is a primitive field component."}
{"class": "labeled dataset field-list", "description": "labeled dataset field-list is defined as a subclass of field-list that must contain at least one member that is a labeled dataset target field component and at least one member that is a labeled dataset descriptive field component. This structure ensures that any labeled dataset field-list necessarily includes both target and descriptive components, reflecting the typical schema of labeled datasets where descriptive fields provide input features and target fields represent outputs or labels."}
{"class": "unlabeled dataset field-list", "description": "unlabeled dataset field-list is a subclass of field-list, characterized by the axiom that its members must include at least one labeled dataset descriptive field component through the has_member property. This means any instance of unlabeled dataset field-list is a field-list that necessarily contains some labeled dataset descriptive field components."}
{"class": "date-time factor", "description": "date-time factor is defined as a subclass of factor. This means every date-time factor is a type of factor, inheriting its general properties and constraints. No additional disjointness or property restrictions are specified, so instances of date-time factor possess all the characteristics of factors, potentially specializing in aspects related to date or time within their domain."}
{"class": "scaled factor", "description": "scaled factor is defined as a subclass of factor. This means that every scaled factor is a specific kind of factor, inheriting all characteristics of factors, but may possess additional properties or constraints related to scaling, depending on further ontology specification. There are no further axioms provided, so this class serves as a specialization for factors that have been subject to scaling."}
{"class": "real factor", "description": "real factor is defined as a subclass of factor. This means every real factor is, by definition, a factor, inheriting all characteristics shared by factors in general. There are no further distinguishing restrictions or properties specified, so real factor can be understood as a type of factor without additional specified constraints."}
{"class": "complex factor", "description": "complex factor is defined as a subclass of factor. This means that every complex factor is a kind of factor, inheriting all properties of the factor class. There are no additional restrictions, disjointness, or property constraints specified for complex factor in the current formalization."}
{"class": "graph aggregate component", "description": "graph aggregate component is defined as a subclass of aggregate field component. This indicates that every graph aggregate component inherits all characteristics of aggregate field components but may have additional specialized properties or constraints. Instances of this class are, therefore, specific types of aggregate field components, potentially involved in representing or handling aggregated data within a graph structure."}
{"class": "dyadic operation", "description": "dyadic operation is defined as a subclass of characterizing operation, and is disjoint with niladic operation, monadic operation, and n-adic operation, ensuring that no individual can be simultaneously classified as any of these mutually exclusive operation types. A dyadic operation is characterized by mapping a pair of values from a given datatype to either another value of the same datatype or to a Boolean value. This formalization supports the clear distinction and function of dyadic operations within the hierarchy of operation arities."}
{"class": "niladic operation", "description": "niladic operation is defined as a subclass of characterizing operation and is explicitly disjoint with both monadic operation and n-adic operation, ensuring that an operation cannot simultaneously belong to these classes. Niladic operations are characterized by yielding values of a given datatype, typically without requiring any input arguments."}
{"class": "monadic operation", "description": "monadic operation is defined as a subclass of characterizing operation and is explicitly disjoint with n-adic operation, meaning an operation cannot be both monadic and n-adic. Monadic operations map a value of the given datatype to either another value of the same datatype or to a Boolean value, thus operating on a single input. This distinguishes monadic operations from n-adic operations, which take multiple inputs."}
{"class": "n-adic operation", "description": "n-adic operation is defined as a subclass of characterizing operation. It represents operations that map ordered n-tuples of values\u2014where each value may belong to a given or parameterized datatype\u2014into a result that is also of the given or a parametric datatype. This class models operations with arity n, generalizing functions over sequences of values and emphasizing their domain and codomain datatype constraints."}
{"class": "attribute-list", "description": "attribute-list is defined as a subclass of list specification, characterized by the requirement that every attribute-list must have at least one member that is an attribute component. This formalization specifies that the class comprises list specifications whose members necessarily include attribute components."}
{"class": "discrete-value-list", "description": "discrete-value-list is defined as a subclass of list specification. Every instance of discrete-value-list must have at least one member that is a discrete-value identifier. This formalization ensures that all discrete-value-lists are specifically collections containing discrete-value identifiers as elements, distinguishing them from other types of lists."}
{"class": "alternative-list", "description": "alternative-list is defined as a subclass of list specification, incorporating a property restriction requiring that its members must include at least one alternative component. This ensures that any instance of alternative-list represents a list specification whose elements are specifically alternative components."}
{"class": "procedure-parameter-list", "description": "procedure-parameter-list is defined as a subclass of list specification, restricted so that it must have at least one member which is a procedure-parameter declaration. This formalization ensures that any instance of procedure-parameter-list represents a list where each member is specifically a declaration pertaining to procedure parameters."}
{"class": "defined generator parameter-list", "description": "defined generator parameter-list is a subclass of list specification. This means every defined generator parameter-list is a type of list specification, inheriting all its properties and constraints. Individuals in this class are formally recognized as specialized list specifications used for defining generator parameters."}
{"class": "defined datatype parameter-list", "description": "defined datatype parameter-list is a subclass of list specification. Each instance of this class is required to have at least one member that is a defined datatype parameter. This formally specifies that any defined datatype parameter-list consists of, or includes, defined datatype parameters as its elements."}
{"class": "select-list", "description": "select-list is defined as a subclass of list specification, representing a specialized type of list that must include at least one member which is a select-item specification. Any instance of select-list is thus required to be a list specification containing one or more select-item specifications as its members."}
{"class": "extended-value-list", "description": "extended-value-list is defined as a subclass of list specification, meaning it inherits the general characteristics of list specifications. Additionally, every member of this class must have at least one associated extended-value identifier, as specified by the property has_identifier. This ensures that all instances of extended-value-list are identifiable through one or more extended-value identifiers."}
{"class": "index-type list", "description": "index-type list is a subclass of list specification, defined as a collection that has at least one member of type index-type. This means any instance of index-type list must contain one or more elements that are classified as index-type."}
{"class": "enumerated-value-list", "description": "enumerated-value-list is defined as a subclass of list specification, with the defining property that it must have at least one member that is an enumerated-value identifier. This means any instance of enumerated-value-list is a list specification characterized by containing one or more explicitly enumerated values as its members."}
{"class": "field-list", "description": "field-list is defined as a subclass of list specification, meaning it inherits all properties of a list specification. Additionally, it is characterized by a property restriction: every field-list must have at least one member that is a field component. This ensures that any instance of field-list specifically contains field components as its members."}
{"class": "tree datatype generator", "description": "tree datatype generator is defined as a subclass of directed labeled graph datatype generator, meaning it inherits all structural properties of directed labeled graphs. Additionally, it is explicitly disjoint with DAG datatype generator, indicating that no datatype generator can be both a tree and a directed acyclic graph (DAG) generator at the same time. This class represents datatype generators that output trees, which are specialized directed labeled graphs, ensuring a clear distinction from generators that produce more general acyclic structures."}
{"class": "DAG datatype generator", "description": "DAG datatype generator is defined as a subclass of directed labeled graph datatype generator. Members of this class inherit all properties of directed labeled graph datatype generators, specializing in generating data types based on directed acyclic graph (DAG) structures. This class is used to represent systems or components that produce datatypes structured according to DAGs, ensuring acyclicity and directionality in their outputs."}
{"class": "array datatype", "description": "array datatype is defined as a subclass of homogenous aggregate datatype, and is explicitly disjoint from homogenous aggregate datatype with variable size, indicating arrays have a fixed size. Members of this class possess the following characteristics: they have members of a specific base type, members are indexed (by an index-type list), and an array can be generated by an array generator. Arrays are associated with qualities such as being exact, non-ordered, and non-numeric. They support operations including selection (Select:table), replacement (Replace:array), and testing for equality (Equal:array). These axioms provide a formal definition capturing the essential nature and operational behavior of array datatypes."}
{"class": "homogenous aggregate datatype with variable size", "description": "homogenous aggregate datatype with variable size is a subclass of homogenous aggregate datatype. Each instance in this class is characterized by having at least one member that is a homogenous aggregate generator with variable size. This means members of this class are structured as aggregates comprised of homogeneous components, and the size or number of these components can vary, as generated by the associated generator."}
{"class": "scaled datatype", "description": "scaled datatype is defined as a subclass of numeric ordered primitive datatype and is disjoint with both integer datatype and rational datatype, meaning it cannot overlap with these types. Members of the scaled datatype class must possess qualities such as being unbounded and exact, and must have members including scaled radix and scaled factor. They also support a defined set of operations, including divide, multiply, add, round, negate, equal, and in-order comparisons, all specific to the scaled datatype. This formalization distinguishes scaled datatype as a numeric primitive that facilitates arithmetic and ordering operations based on scaling factors, but is neither a traditional integer nor a rational type."}
{"class": "real datatype", "description": "real datatype is defined as a subclass of numeric ordered primitive datatype and is explicitly disjoint with both integer datatype and rational datatype, ensuring that no individual can be simultaneously classified as a real datatype and either of those classes. Members of this class support a range of operations, including addition (Add), multiplication (Multiply), negation (Negate), reciprocals (Reciprocal), equality comparison (Equal), order comparison (InOrder), and type promotion (Promote), all among real values. Instances of real datatype possess qualities of being unbounded and approximate, distinguishing them from other numeric types. They also include members such as real radix and real factor, further characterizing the structure and application of real datatypes."}
{"class": "integer datatype", "description": "integer datatype is a subclass of numeric ordered primitive datatype, characterized by qualities such as being ordered, numeric, exact, and unbounded. It supports operations including addition, multiplication, negation, equality checking, and ordered comparison among integers, as well as ensuring the existence of non-negative integers. The class is explicitly disjoint with rational datatype, indicating that no individual can be both an integer and a rational that is not an integer. These axioms formalize the mathematical and operational properties unique to the integer datatype."}
{"class": "rational datatype", "description": "rational datatype is defined as a subclass of numeric ordered primitive datatype. It possesses several qualities: it is numeric, ordered, exact, and unbounded. Individuals in this class support a set of operations, including multiplication, addition, negation, equality testing, reciprocal, in-order comparison, non-negativity, and promotion. These characteristics collectively formalize the rational datatype as representing rational numbers that are precise, can be manipulated with various arithmetic operations, and do not have inherent bounds on size or value."}
{"class": "non-aggregate generator", "description": "non-aggregate generator is defined as a subclass of generated datatype generator, and is explicitly disjoint from defined generator, aggregate datatype, and aggregate generator. Every non-aggregate generator is equivalent to being either a choice generator, pointer generator, or procedure generator. This class groups generator types that are not aggregate in nature, thereby excluding those that represent defined, aggregate, or aggregate-related generator functionalities."}
{"class": "aggregate generator", "description": "aggregate generator is defined as a subclass of generated datatype generator and is equivalent to any generator that is either an array generator, bag generator, class generator, record generator, sequence generator, set generator, or table generator. This class serves as a synonym for \"aggregate datatype constructor,\" reflecting its role in constructing aggregate or composite datatypes from collections of elements or records."}
{"class": "identifier", "description": "identifier is defined as a subclass of information artifact entity. Members of this class represent informational constructs specifically designed to uniquely distinguish or label entities, concepts, or data within information systems. This formalization means every identifier is categorized under the broader class of information artifact entities, emphasizing its role in conveying and maintaining unique identity information."}
{"class": "value expression", "description": "value expression is a subclass of information artifact entity. This means every value expression is formally classified as a type of information artifact entity, inheriting all its general properties and restrictions. No additional axioms or property restrictions are specified, so value expression is currently distinguished solely by its classification within the ontology hierarchy as a specialized form of information artifact entity."}
{"class": "label", "description": "label is defined as a subclass of information artifact entity, indicating that it represents a type of information artifact. Instances of this class are understood to bear, convey, or represent information, typically serving as markers or identifiers that provide descriptive or categorical details about other entities."}
{"class": "directive information entity", "description": "directive information entity is defined as a subclass of information artifact entity. This means that every directive information entity is a type of information artifact entity, with no additional property restrictions or disjointness specified. Members of this class represent entities that are informational in nature and classified within the broader category of information artifact entities."}
{"class": "representation", "description": "representation is defined as a subclass of information artifact entity, indicating that every instance of representation is an information-based object or artifact. This formalization situates representations within the broader context of informational entities, ensuring that they inherit all characteristic properties of information artifact entities. There are no additional property restrictions or disjointness conditions specified for this class."}
{"class": "specification", "description": "specification is defined as a subclass of information artifact entity. This means every specification is considered a type of information artifact, formally representing structured information or requirements typically used to describe, detail, or govern the properties or behavior of an entity, system, or process."}
{"class": "exactness", "description": "exactness is defined as a subclass of datatype property and is explicitly disjoint from the classes numericalness, cardinality, order, boundedness, and equality\u2014meaning no instance can belong to any of these classes simultaneously. Additionally, exactness is equivalent to the union of approximate or exact, capturing the notion that it characterizes properties specifying whether something is described with complete precision or approximation. This class formally distinguishes the aspect of being exact from other quantitative or structural datatype attributes."}
{"class": "numericalness", "description": "numericalness is a subclass of datatype property that classifies properties as either numeric or non-numeric. It is formally specified to be equivalent to the union of numeric and non-numeric, meaning all members must belong to one of these two categories. Additionally, numericalness is explicitly disjoint with cardinality, order, boundedness, and equality, ensuring these property types are mutually exclusive and no property can simultaneously belong to both numericalness and any of these other classes. This class captures the essential distinction between properties based on their numerical character."}
{"class": "cardinality", "description": "cardinality is a subclass of datatype property and is disjoint from the classes order, boundedness, and equality, meaning no entity can simultaneously belong to both cardinality and any of these classes. It is formally equivalent to the union of countable, finite, and uncountable, reflecting that cardinality expresses the size or \"number of elements\" in a set, which may be countable, finite, or uncountable. This structure ensures clear differentiation from related set properties such as order, boundedness, and equality."}
{"class": "order", "description": "order is defined as a subclass of datatype property, meaning it is a specific kind of property whose value is a data value (as opposed to an object property). It is explicitly disjoint from the classes boundedness and equality, ensuring that no property instance can simultaneously be classified under these categories. Furthermore, order is equivalent to the union of ordered and non-ordered, indicating that any property that falls under the order class must be characterized as either ordered or non-ordered, and these two subclasses exhaust all possibilities for order. This structure formally differentiates order-related properties from those related to boundedness or equality."}
{"class": "boundedness", "description": "boundedness is defined as a subclass of datatype property and is explicitly disjoint with equality, indicating that no instance can simultaneously represent boundedness and equality. It is further specified as being equivalent to either bounded or unbounded, meaning every instance of boundedness must fall into one of these two categories. This class formally captures the notion of whether a datatype property exhibits bounds or not, distinguishing it from properties concerning equality."}
{"class": "equality", "description": "equality is defined as a subclass of datatype property, indicating that it represents a specific type of property that links individuals to data values. This classification ensures that equality is used exclusively in contexts appropriate for datatype properties, which relate individuals to literal values rather than to other individuals."}
{"class": "vector datatype", "description": "vector datatype is defined as a subclass of array datatype. Every vector datatype must have at least one member that is generated by or corresponds to a vector generator, as specified by the property restriction [has_member some vector generator]. This formalizes vector datatypes as array datatypes with elements produced or related to a specific generation mechanism."}
{"class": "maximum-size", "description": "maximum-size is a subclass of size, representing the largest possible or allowable extent within a given context. Any individual classified as maximum-size must also be an instance of size, specifying the upper limit or boundary in measurement or quantity."}
{"class": "minimum-size", "description": "minimum-size is defined as a subclass of size, indicating that it represents a more specific concept within the broader category of size. Members of this class inherit all characteristics of size, and are distinguished by representing some form of minimum or least amount within size-related contexts."}
{"class": "discrete field component", "description": "discrete field component is a subclass of primitive field component and is explicitly disjoint with both real field component and boolean field component, ensuring that no individual can be classified as more than one of these types. Members of this class are characterized by their relationship to discrete datatypes, as every discrete field component must play the role of some discrete datatype. This formalization distinguishes discrete field components from other primitive field components based on their association with discrete data."}
{"class": "real field component", "description": "real field component is defined as a subclass of primitive field component, disjoint with boolean field component\u2014which ensures that no individual can be both a real field component and a boolean field component simultaneously. Members of this class are further constrained by a property restriction: each real field component must have a role with respect to some real datatype. This means that any real field component always relates in some way to a real (numeric, continuous) datatype, distinguishing it from other types of primitive field components."}
{"class": "boolean field component", "description": "boolean field component is defined as a subclass of primitive field component and is characterized by the restriction that it must have some relationship (role_of) to a boolean datatype. This means every boolean field component represents or is associated with a value that is strictly of boolean type (such as true or false), distinguishing it from other field components that may represent different primitive datatypes."}
{"class": "pointer datatype", "description": "pointer datatype is a subclass of non-aggregate datatype, whose values act as references to values of another datatype (the element datatype), and each value is atomic. Members of this class are characterized by possessing non-ordered and non-numeric qualities, and have \u201cexact\u201d as a quality. Additionally, every pointer datatype must have members corresponding to a pointer generator and a pointer-element-type, along with operations for equality (Equal:pointer) and dereferencing (Dereference:pointer). This formalization ensures that pointers are distinct, reference-capable datatypes with well-defined generative and operational properties but are not ordered or numeric collections."}
{"class": "choice datatype", "description": "choice datatype is a subclass of non-aggregate datatype, characterized by having values that represent a single value selected from a set of alternative datatypes. These alternative datatypes are differentiated by their correspondence to values from a tag-type, known as the tag datatype. Formally, a choice datatype has members such as tag-type, alternative-list, and a choice generator; it is subject to property restrictions requiring qualities such as exactness and being non-ordered. It supports specific operations, including Discriminant:choice, Tag:choice, Cast:choice, and Equal:choice, which facilitate the selection and identification of alternatives by tag values."}
{"class": "procedure datatype", "description": "procedure datatype is defined as a subclass of non-aggregate datatype. Instances of this class represent atomic values that are operations (procedures) on values of designated parameter datatypes. A procedure datatype must possess non-numeric, exact, and non-ordered qualities, and it is composed of specific members: a procedure generator, a procedure-parameter list, and a return-parameter specification. It is also characterized by having at least the operations \u2018Equal:procedure\u2019 and \u2018Invoke:procedure\u2019. This formalization encapsulates all operations on a collection of datatypes, treating each procedure as an indivisible (atomic) value."}
{"class": "tree datatype", "description": "tree datatype is defined as a subclass of labeled graph datatype, ensuring that every tree datatype inherits all structural features of labeled graph datatypes. It is explicitly disjoint with DAG datatype, meaning no instance can simultaneously belong to both classes. Additionally, every member of the tree datatype class must have at least one associated tree datatype generator, as specified by the property restriction. This formalization captures tree datatypes as hierarchical, non-cyclic structures generated by specific mechanisms and distinct from more general directed acyclic graphs."}
{"class": "DAG datatype", "description": "DAG datatype is specified as a subclass of labeled graph datatype, meaning it inherits all characteristics of a labeled graph datatype. Additionally, every DAG datatype must have at least one member that is a DAG datatype generator, as indicated by the property restriction [has_member some DAG datatype generator]. This ensures each instance of DAG datatype is associated with a generator tailored for directed acyclic graph structures."}
{"class": "aggregate generator property", "description": "aggregate generator property is defined as a subclass of quality, indicating that it represents a specialized type of quality. Members of this class inherit all characteristics of qualities, and specifically pertain to attributes or aspects associated with aggregate generators. No additional restrictions or disjointness axioms are specified."}
{"class": "datatype property", "description": "datatype property is defined as a subclass of quality, indicating that each instance of datatype property inherits characteristics associated with quality. This classification suggests that datatype properties are viewed as specific types of qualities within the ontology."}
{"class": "upper bound", "description": "upper bound is defined as a subclass of bound, representing a specific type of bound characterized by having exactly one value of type xsd:integer associated through the has-value property. This formalization ensures that every instance of upper bound uniquely specifies a single integer value as its bound."}
{"class": "lower bound", "description": "lower bound is defined as a subclass of bound, representing a specific type of bound that is associated with exactly one integer value via the has-value property. This restriction ensures that each lower bound instance is uniquely identified by a single integer."}
{"class": "index upperbound", "description": "index upperbound is defined as a subclass of bound, characterized by the property restriction that it must have exactly one value of type xsd:integer. This ensures that any instance of index upperbound represents a unique integer value serving as an upper bound within an indexing context."}
{"class": "index lowerbound", "description": "index lowerbound is a subclass of bound, representing a specific type of boundary. It is characterized by the property restriction that it must have exactly one value of type xsd:integer, indicating the precise lower limit or starting point within an index or range. This formalization ensures that each instance of index lowerbound uniquely defines a single integer value as its boundary."}
{"class": "character datatype", "description": "character datatype is defined as a subclass of non-numeric unordered primitive datatype. It is disjoint with discrete datatype and boolean datatype, ensuring that no datatype can be both a character datatype and either of those types. Members of the character datatype class are characterized by possessing at least one exact quality, supporting the Equal operation restricted to characters, and being associated with at least one character-set identifier. This formalization captures the essential properties of character datatypes, which are used to represent single text characters from specific character sets and are distinct from numeric or logical datatypes."}
{"class": "discrete datatype", "description": "discrete datatype is a subclass of non-numeric unordered primitive datatype, and it is explicitly disjoint with boolean datatype, ensuring that no individual can be both a discrete datatype and a boolean datatype. Members of this class must have at least one member from a discrete-value-list, support at least the equality operation (Equal:discrete), and possess the quality of exactness. This formalization captures the distinct, non-numeric, unordered nature of discrete datatypes, characterized by well-defined, separate values and an emphasis on precise equality comparisons."}
{"class": "boolean datatype", "description": "boolean datatype is defined as a subclass of non-numeric unordered primitive datatype. It has qualities that are non-ordered, non-numeric, and exact, indicating that boolean values are discrete, precise, and lack inherent ordering or numeric magnitude. Instances of boolean datatype support specific logical operations, including Not, And, Or, and Equal, with all operations yielding boolean results. This formalization captures the core characteristics of the boolean datatype: a primitive type that represents values with two alternatives (typically true and false), distinct from numeric or ordered datatypes, and amenable to fundamental logic operations."}
{"class": "defined generator", "description": "defined generator is a subclass of datatype generator. Every instance of defined generator is required to be associated with at least one defined datatype through the property is_member_of. This formalization ensures that defined generators are specifically linked to defined datatypes within the ontology."}
{"class": "generated datatype generator", "description": "generated datatype generator is defined as a subclass of datatype generator and is considered equivalent to either a non-aggregate generator or an aggregate generator. Members of this class must be associated, via the is_member_of property, with some generated datatype. The class is also described by the synonym \"datatype constructor.\""}
{"class": "subtype generator", "description": "subtype generator is defined as a subclass of datatype generator, indicating that every instance of subtype generator is also an instance of datatype generator. This classification specifies that subtype generators operate within the broader framework of datatype generators but may provide more specialized or refined functionality. No additional disjointness or property restrictions are specified."}
{"class": "discrete base type", "description": "discrete base type is defined as a subclass of base type, and is disjoint with real base type, ensuring that no individual can belong to both classes simultaneously. Members of this class participate in the role_of relationship with at least one discrete datatype, meaning that every discrete base type must be associated with some discrete datatype. This formalization distinguishes discrete base types from real base types and characterizes them by their association with discrete datatypes."}
{"class": "real base type", "description": "real base type is defined as a subclass of base type, with the additional restriction that every real base type must serve as the role_of some real datatype. This means that any individual belonging to real base type participates in the role_of property relation to at least one real datatype, thereby explicitly connecting real base type to the real datatype concept within the ontology structure."}
{"class": "integer base datatype", "description": "integer base datatype is defined as a subclass of base type and is constrained by the axiom that it must play the role of some integer datatype. This means that every instance of integer base datatype is a specific kind of base type that is characterized by being related to at least one integer datatype through the role_of property."}
{"class": "record of boolean datatype", "description": "record of boolean datatype is a subclass of record (tuple) datatype, disjoint from both record of real datatype and record of discrete datatype, ensuring that no individual can belong to any two of these classes simultaneously. Members of this class are characterized by having at least one member that is a boolean field-list, meaning each record must include at least one field of boolean type. This enforces that the records grouped under this class are distinguished by containing boolean data fields."}
{"class": "record of real datatype", "description": "record of real datatype is defined as a subclass of record (tuple) datatype, and is explicitly disjoint with record of discrete datatype, ensuring that no individual can belong to both categories. Members of this class are characterized by the presence of at least one member field (has_member) that is of real type within its field-list. This constrains records in this class to contain real-valued data fields, distinguishing them from records composed entirely of discrete datatypes."}
{"class": "record of primitives datatype", "description": "record of primitives datatype is defined as a subclass of record (tuple) datatype. Members of this class are characterized by the property restriction that they must have at least one member that is a primitive field-list. This formalization ensures that any instance of record of primitives datatype represents a structured record whose fields are all of primitive types."}
{"class": "record of discrete datatype", "description": "record of discrete datatype is a subclass of record (tuple) datatype, characterized by the requirement that it must have at least one member drawn from a discrete field-list. This ensures that instances of this class represent tuple datatypes whose components include one or more fields with discrete (distinct, countable) values."}
{"class": "labeled dataset record datatype", "description": "labeled dataset record datatype is defined as a subclass of record (tuple) datatype. Each instance must have exactly one member, specified by the has_member property, which must be a labeled dataset field-list. This ensures that every labeled dataset record datatype represents a tuple structure with a precisely defined schema for its contents."}
{"class": "unlabeled dataset record datatype", "description": "unlabeled dataset record datatype is defined as a subclass of record (tuple) datatype. Members of this class are characterized by the presence of at least one has_member relationship to an unlabeled dataset field-list, meaning each record contains a list of fields but without associated labels. This structure is suitable for representing data records in datasets where attribute names are absent."}
{"class": "date-time unit", "description": "date-time unit is defined as a subclass of label, indicating that it represents a specific type of label used to denote units of time such as seconds, minutes, or hours in the context of date and time. No additional constraints or disjointness are specified, so its primary distinguishing feature is its specialization from the broader category of label."}
{"class": "set of discrete datatype", "description": "set of discrete datatype is defined as a subclass of set datatype, representing collections where each member belongs to a discrete base type (such as integers or other countable values). This class is explicitly disjoint from set of real datatype, ensuring that no instance can simultaneously be a set of both discrete and real datatypes. The axiom requires that every member of a set of discrete datatype must be of a discrete base type, emphasizing its use for finite or countably infinite elements."}
{"class": "set of real datatype", "description": "set of real datatype is defined as a subclass of set datatype, where every instance must contain at least one member of the real base type. This means that any set classified under this class necessarily includes real numbers among its elements, distinguishing it from other datatype sets whose members may be of different types."}
{"class": "set of integer datatype", "description": "set of integer datatype is defined as a subclass of set datatype. Each instance of this class is constrained by the requirement that it has members, all of which are from the integer base datatype. This ensures that any individual classified as set of integer datatype can only contain integers as its elements."}
{"class": "aggregate datatype", "description": "aggregate datatype is defined as a subclass of generated datatype and is explicitly disjoint with non-aggregate datatype, ensuring that no individual can be both an aggregate and a non-aggregate datatype. It is characterized by having at least one member that is an aggregate generator (has_member some aggregate generator). Commonly referred to as a \"structured datatype,\" this class captures datatypes that are composed of multiple components or members rather than being atomic."}
{"class": "non-aggregate datatype", "description": "non-aggregate datatype is defined as a subclass of generated datatype. All members of this class are characterized by the property restriction that they must have at least one member (has_member) that is a non-aggregate generator. This formalization ensures that any non-aggregate datatype is generated through or associated with at least one non-aggregate generator, distinguishing it from other types of generated datatypes."}
{"class": "enumerated datatype", "description": "enumerated datatype is defined as a subclass of non-numeric ordered primitive datatype, and is explicitly disjoint with both date and time datatype and ordinal datatype. As a discrete (synonymously, enumerated) datatype, it is characterized by having an explicit set of member values (enumerated-value-list) and supports specific operations such as equality checking (Equal:enumerated), successor determination (Successor:enumerated), and ordered comparison (InOrder:enumerated). Additionally, every enumerated datatype must possess qualities of being bounded (having finite limits) and exact (precisely defined), ensuring it only allows selection from a strictly defined, ordered set of non-numeric values."}
{"class": "date and time datatype", "description": "date and time datatype is a subclass of non-numeric ordered primitive datatype, and is explicitly disjoint with ordinal datatype\u2014meaning no instance can simultaneously belong to both classes. Members of this class possess qualities of being exact and potentially unbounded, and they necessarily have members such as date-time units, date-time radices, and date-time factors. The class supports specific operations, including extension, equality checking, ordering, difference calculation, and rounding of date and time values. This formalization ensures a precise and operation-rich definition of datatypes used for representing and manipulating combined date and time information, distinct from ordinal forms of data."}
{"class": "ordinal datatype", "description": "ordinal datatype is a subclass of non-numeric ordered primitive datatype. It is defined by possessing a set of operations and qualities: members must support operations such as \"InOrder\", \"Successor\", and \"Equal\" specific to ordinals. Ordinal datatypes are characterized by being ordered, exact, non-numeric in nature, and always bounded below but may be unbounded above. This constrains ordinal datatypes to those that allow clear ordering of their instances, with well-defined succession and equality, but without numeric interpretation."}
{"class": "date-time radix", "description": "date-time radix is defined as a subclass of radix. This indicates that any instance of date-time radix inherits all characteristics of radix, while potentially adding more specific constraints or properties relevant to date and time representation bases. No further description or property restrictions are provided."}
{"class": "complex radix", "description": "complex radix is a subclass of radix. This means every complex radix is a type of radix, inheriting all the general properties of radix. There are no additional property restrictions or disjointness axioms specified, so complex radix is simply categorized as a specialized form within the broader radix class."}
{"class": "real radix", "description": "real radix is a subclass of radix, representing those members of radix that have the property of being real. Every real radix is formally included in the broader category of radix, but may possess additional distinguishing characteristics specifying real-valued properties. No further property restrictions or disjointness axioms are specified."}
{"class": "scaled radix", "description": "scaled radix is defined as a subclass of radix. This means every instance of scaled radix is also considered a radix. No additional property restrictions or disjointness axioms are specified, so a scaled radix inherits all characteristics of radix, potentially with further differentiation implied by its name or use context."}
{"class": "factor", "description": "factor is defined as a subclass of value expression, indicating that every instance of factor is also recognized as a value expression. There are no additional restrictions or disjointness axioms specified, so factor inherits all characteristics of value expressions without further constraints."}
{"class": "size", "description": "size is defined as a subclass of value expression, representing a value-based concept within the ontology. Members of the size class are characterized by having exactly one associated value of type xsd:integer through the has-value property. This means each individual of size must specify a single integer value, reflecting the quantitative measurement that the class is intended to capture."}
{"class": "radix", "description": "radix is defined as a subclass of value expression. This indicates that any radix is a specific kind of value expression, inheriting all characteristics of value expressions and further specializing their meaning, typically referring to the numerical base in mathematical or computational contexts."}
{"class": "range", "description": "range is defined as a subclass of value expression. Members of this class are characterized by having at least one association, through the property has_member, to both a lower bound and an upper bound. This formalization ensures that each instance of range must specify some lower and some upper bound, thereby representing a bounded interval or extent within the context of value expressions."}
{"class": "bound", "description": "bound is defined as a subclass of value expression, indicating that every instance of bound is also considered a value expression. No further restrictions or disjointness axioms are specified, so the defining characteristic of the bound class is its inheritance from value expression."}
{"class": "datatype", "description": "datatype is defined as a subclass of data representational model. Members of this class are characterized by three property restrictions: they possess at least one datatype property (has_quality some datatype property), are associated with at least one characterizing operation (has_operation some characterizing operation), and have at least one value space (has_attribute some value space). This formalization ensures that any individual classified as a datatype is a type of data representation distinguished by its qualities, the operations applicable to it, and its defined set of possible values."}
{"class": "extended datatype", "description": "extended datatype is defined as a subclass of data representational model. It is characterized by possessing at least one datatype property (has_quality some datatype property), at least one subtype generator as a member (has_member some subtype generator), at least one value space attribute (has_attribute some value space), and at least one base type as a member (has_member some base type). The class is also associated with the synonym \"subtype\". This formalization ensures that any instance of extended datatype is richly described in terms of qualities, generative subtypes, value domains, and derived from fundamental base types."}
{"class": "complex datatype", "description": "complex datatype is defined as a subclass of numeric primitive datatype and is disjoint with numeric ordered primitive datatype\u2014meaning no individual can simultaneously belong to both classes. Members of this class are characterized as numeric, non-ordered, and approximate in nature. They support operations specific to complex numbers, such as reciprocal, negation, square root, multiplication, addition, promotion, and equality (all in the complex domain). Instances of complex datatype must include members such as complex radix and complex factor. This formalization captures the essential characteristics and operations associated with complex numbers in data representation, distinguishing them from ordered numeric primitive datatypes."}
{"class": "numeric ordered primitive datatype", "description": "numeric ordered primitive datatype is defined as a subclass of numeric primitive datatype, with the additional restriction that it must possess the quality of being ordered. This means that any datatype in this class is numeric by nature and supports an intrinsic ordering, enabling comparison between its members (e.g., less than, greater than relationships)."}
{"class": "sequence of discrete datatype", "description": "sequence of discrete datatype is defined as a subclass of sequence datatype, meaning it inherits all characteristics associated with sequence datatypes. Individuals of this class are further characterized by the property that each member of the sequence must be of a discrete base type. This restriction ensures that only elements classified as discrete base types are permitted as members in such sequences, differentiating this class from more general sequence datatypes that may include other types of elements."}
{"class": "sequence of real datatype", "description": "sequence of real datatype is a subclass of sequence datatype, characterized by the restriction that its members must be of the real base type. This means every element within a sequence of this type is a real number, ensuring that the sequence contains no members of other datatypes."}
{"class": "sequence datatype", "description": "sequence datatype is defined as a subclass of homogenous aggregate datatype with variable size, and is explicitly disjoint with homogenous unordered aggregate datatype with variable size, ensuring no individual can belong to both classes. Members of this class are characterized by being non-ordered and non-numeric, containing only elements (members) of a base type and potentially a sequence generator. Sequence datatype supports several operations: checking for equality with another sequence, checking if the sequence is empty, retrieving the head (first element), appending elements, and retrieving the tail (all elements except the head). The inclusion of only these features signifies that sequence datatype represents an ordered, variable-sized, homogenous collection of elements with well-defined sequence-based operations."}
{"class": "homogenous  unordered aggregate datatype with variable size", "description": "homogenous unordered aggregate datatype with variable size is a subclass of homogenous aggregate datatype with variable size. Each instance of this class must have at least one member that is an instance of homogenous unordered aggregate generator with variable size. This class groups together collections of elements that are all of the same type, where the order of elements is not significant, and the number of elements may vary."}
{"class": "bag datatype", "description": "bag datatype is defined as a subclass of homogenous unordered aggregate datatype with variable size, and is explicitly disjoint with set datatype, ensuring that no instance can be both a bag and a set. Members of this class are characterized by containing elements (members) from a specified base type as well as from possible bag generators. Bags possess qualities of being non-ordered (element sequence is not significant), non-numeric, and \"exact\" (potentially referring to preserving element multiplicities). Bags support the following operations: Select, Insert, Delete, IsEmpty, Equal, and Serialize. This formalization models bags as flexible, unordered collections that can contain duplicate elements, are distinguished from sets by their handling of element multiplicity, and provide standard collection manipulation operations."}
{"class": "set datatype", "description": "set datatype is a subclass of homogenous unordered aggregate datatype with variable size. It is characterized by being non-ordered, non-numeric, and exact. Individuals of this class have members that are of some base type or set generator and support operations such as set creation (Lsln:set), intersection, selection, equality checking, set construction (SetOf:set), checking emptiness (Empty:set), difference, union, and subset. This formalization reflects the mathematical concept of sets: collections consisting of distinct, unordered elements of the same type, with a well-defined suite of set-theoretic operations."}
{"class": "node component", "description": "node component is defined as a subclass of graph aggregate component and is explicitly disjoint with edge component, meaning an individual cannot simultaneously be a node component and an edge component. This class represents components within a graph structure that function as nodes, distinct from components serving as edges."}
{"class": "edge component", "description": "edge component is defined as a subclass of graph aggregate component. This means that every edge component is a specialized type of graph aggregate component, inheriting all its characteristics. The class represents a distinct part or module within the broader category of aggregated components in graph structures. No additional property restrictions or disjointness axioms are specified."}
{"class": "aggregate field component", "description": "aggregate field component is defined as a subclass of field component and is explicitly disjoint with primitive field component, meaning no instance can belong to both classes simultaneously. Every aggregate field component must play the role of or be associated with some aggregate datatype, as specified by the property restriction (role_of some aggregate datatype). This formalization captures that aggregate field components are complex field components characterized by their association with aggregate datatypes, distinguishing them from primitive field components."}
{"class": "primitive field component", "description": "primitive field component is defined as a subclass of field component, where each member must play the role of some primitive datatype. This means that any primitive field component is intrinsically linked to a primitive datatype, distinguishing it from other types of field components that may be associated with more complex data structures."}
{"class": "labeled dataset descriptive field component", "description": "labeled dataset descriptive field component is defined as a subclass of field component. This means every labeled dataset descriptive field component is by definition a type of field component. No additional property restrictions or disjointness constraints are specified, so its unique characterization is its specialization of the more general field component class."}
{"class": "labeled dataset target field component", "description": "labeled dataset target field component is defined as a subclass of field component. This means every labeled dataset target field component is a specific type of field component, typically representing the target variable in a labeled dataset. No additional property or disjointness restrictions are specified for this class."}
{"class": "void datatype", "description": "void datatype is a subclass of primitive datatype and is explicitly disjoint from non-numeric primitive datatype, numeric primitive datatype, and non-numeric unordered primitive datatype\u2014no individual can belong to more than one of these categories. Members of the void datatype class are characterized by supporting at least the Equal:void operation, meaning comparison for equality is defined. This class formalizes the concept of a primitive datatype that does not represent numeric or non-numeric unordered values, distinguishing it within datatype hierarchies."}
{"class": "non-numeric primitive datatype", "description": "non-numeric primitive datatype is a subclass of primitive datatype and is explicitly disjoint with numeric primitive datatype, ensuring no individual can belong to both classes simultaneously. Members of this class must possess at least one quality that is non-numeric, as specified by the existential property restriction [has_quality some non-numeric]. This formalization captures primitive datatypes whose essential characteristics are not quantifiable numerically."}
{"class": "numeric primitive datatype", "description": "numeric primitive datatype is defined as a subclass of primitive datatype and is characterized by the restriction that its instances must possess at least one quality that is numeric in nature. This class captures all primitive datatypes that inherently have numeric qualities, distinguishing them from other primitive datatypes that may not involve numeric properties."}
{"class": "homogenous aggregate generator", "description": "homogenous aggregate generator is defined as a subclass of aggregate generator and is equivalent to any generator that is an array generator, bag generator, sequence generator, or set generator. It is explicitly disjoint with heterogenous aggregate generator, meaning that no individual can belong to both classes simultaneously. Members of this class are further characterized by the property restriction that they must have at least one quality that is homogenous, indicating that the elements they generate are of a uniform type or nature."}
{"class": "heterogenous aggregate generator", "description": "heterogenous aggregate generator is a subclass of aggregate generator and is equivalent to any class that is either a class generator, record generator, or table datatype. Members of this class possess the quality of being heterogenous, indicating that they generate or represent aggregates containing elements of diverse types or structures. This formalization ensures that any heterogenous aggregate generator is characterized by its structural diversity and can functionally align with multiple generator types."}
{"class": "non-numeric unordered primitive datatype", "description": "non-numeric unordered primitive datatype is defined as a subclass of non-numeric primitive datatype, and is explicitly disjoint with non-numeric ordered primitive datatype, ensuring that no datatype can simultaneously be both unordered and ordered. Members of this class are characterized by the property restriction that they possess the quality of being non-ordered (has_quality some non-ordered), indicating that instances do not have an inherent order among their possible values."}
{"class": "non-numeric ordered primitive datatype", "description": "non-numeric ordered primitive datatype is a subclass of non-numeric primitive datatype. Members of this class are characterized by possessing the quality of being ordered, meaning their values can be arranged in a specific sequence or order. This formalization specifies that any non-numeric primitive datatype classified here must inherently support order among its instances."}
{"class": "homogenous aggregate datatype", "description": "homogenous aggregate datatype is defined as a subclass of aggregate datatype, and is explicitly disjoint with heterogenous aggregate datatype, ensuring that no individual can belong to both classes simultaneously. Members of this class are characterized by the property that they must have at least one member that is a homogenous aggregate generator. This formalization captures collections whose elements are produced by uniform (homogeneous) mechanisms, distinguishing them from heterogeneous aggregates both in structure and membership requirements."}
{"class": "heterogenous aggregate datatype", "description": "heterogenous aggregate datatype is defined as a subclass of aggregate datatype. Members of this class are characterized by the existence of at least one member (via the has_member property) that is a heterogenous aggregate generator. This axiom formalizes that any instance of heterogenous aggregate datatype must include, as part of its structure, a heterogenous aggregate generator, distinguishing it from other kinds of aggregate datatypes."}
{"class": "direct access property", "description": "direct access property is a subclass of access type and is disjoint with indirect access property, meaning no property can be both a direct access property and an indirect access property. It is formally defined as being equivalent to either index access or key access, specifying that any direct access property allows retrieval via a direct key or index rather than through intermediary steps."}
{"class": "indirect acess property", "description": "indirect access property is a subclass of access type, and is formally equivalent to any access performed either by value, in an implementation dependent manner, or by position. This means any instance of indirect access property is characterized by one or more of these access forms, distinguishing it from other access type subclasses."}
{"class": "add operation", "description": "add operation is defined as a subclass of dyadic arithmetic operation, indicating that it is an arithmetic operation that takes exactly two arguments. This formalization positions add operation within the hierarchy of arithmetic functions involving pairs of inputs, such as addition in standard mathematics."}
{"class": "multiply operation", "description": "multiply operation is defined as a subclass of dyadic arithmetic operation, indicating that it is an arithmetic operation involving exactly two operands. Instances of this class perform multiplication, processing two input values to produce their product."}
{"class": "Divide:scaled", "description": "Divide:scaled is defined as a subclass of dyadic arithmetic operation. This indicates that it represents an arithmetic operation involving two inputs (operands). No further description or distinguishing constraints are specified by the current axioms, so its meaning is inherited from the broader category of dyadic arithmetic operations."}
{"class": "delete operation", "description": "delete operation is a subclass of dyadic updating operation. This means that every delete operation is considered a specific type of updating operation that involves two entities (typically an object and context). The axiom establishes the hierarchical relationship, indicating that delete operation inherits all structural characteristics of dyadic updating operations."}
{"class": "insert operation", "description": "insert operation is defined as a subclass of dyadic updating operation. This means that every insert operation is considered a specific type of dyadic updating operation, typically involving two entities and resulting in an update. No further distinguishing characteristics or property restrictions are specified."}
{"class": "Append:sequence", "description": "Append:sequence is defined as a subclass of dyadic updating operation, meaning it is a specific type of operation that updates data by taking two inputs. This class formalizes the concept of appending one sequence to another as an update, inheriting the general properties of dyadic updating operations."}
{"class": "AttributeFunctionOverride:class", "description": "AttributeFunctionOverride:class is defined as a subclass of dyadic updating operation. This indicates that any member of AttributeFunctionOverride:class represents a special kind of operation within the scope of dyadic updating, where typically two entities are involved in an updating process. Without further restriction or description, all instances of this class inherit the structural and semantic characteristics of dyadic updating operations."}
{"class": "AttributeReplace:class", "description": "AttributeReplace:class is defined as a subclass of dyadic updating operation. This means it represents a type of operation that updates data by replacing an attribute, and, as a dyadic operation, it involves two input entities. No further restrictions, disjointness, or property constraints are specified in the axiom, so its primary characterization is as a specialized updating action within the context of dyadic operations."}
{"class": "FieldReplace:record", "description": "FieldReplace:record is defined as a subclass of dyadic updating operation. This means that it represents a specific type of updating operation involving two arguments or entities. As a subclass, FieldReplace:record inherits all the general characteristics of dyadic updating operations and is further specialized to represent operations where a field in a record is replaced or updated. No additional restrictions or disjointness axioms are specified."}
{"class": "difference operation", "description": "difference operation is defined as a subclass of dyadic operation, indicating it is a mathematical operation that requires exactly two operands. As a specific type of dyadic operation, the difference operation computes the result by evaluating the \"difference\" between its two input elements, distinguishing it from other dyadic operations such as sum or product."}
{"class": "dyadic select operation", "description": "dyadic select operation is defined as a subclass of dyadic operation, signifying that it is a binary operation acting on two operands. No additional constraints or distinguishing characteristics are specified beyond its membership in the broader class of dyadic operations."}
{"class": "dyadic aritmetic operation", "description": "dyadic arithmetic operation is defined as a subclass of dyadic operation, indicating that every dyadic arithmetic operation involves exactly two inputs (operands). This class specifically focuses on operations in the arithmetic domain (such as addition, subtraction, multiplication, or division), extending the more general concept of dyadic operations by emphasizing their application to arithmetic computations."}
{"class": "dyadic logical operation", "description": "dyadic logical operation is defined as a subclass of dyadic operation, meaning it is an operation that takes exactly two inputs. This class specifically refers to logical operations (such as AND, OR, XOR) applied to two operands, distinguishing it from other kinds of dyadic operations that may not be logical in nature."}
{"class": "dyadic set operation", "description": "dyadic set operation is defined as a subclass of dyadic operation. This class encompasses operations that act on two sets as inputs. Members of this class must satisfy all properties of dyadic operations, specifically within the context of set-theoretic functions or relations."}
{"class": "dyadic updating operation", "description": "dyadic updating operation is defined as a subclass of dyadic operation, indicating that it involves two operands. While specific characteristics are not provided, this class inherits all properties of dyadic operations, typically meaning it operates on pairs of entities or values."}
{"class": "dyadic comparison operation", "description": "dyadic comparison operation is a subclass of dyadic operation. This class encompasses operations that involve two arguments and perform a comparative evaluation between them. Members of this class, as dyadic operations, specifically relate to comparison tasks (such as \"greater than\", \"less than\", or \"equal to\") applied to pairs of inputs."}
{"class": "dyadic retrieve operation", "description": "dyadic retrieve operation is defined as a subclass of dyadic operation, indicating it is an operation that acts on exactly two inputs or entities. No further distinguishing axioms or properties are specified, so its classification relies solely on this generalization."}
{"class": "equal operation", "description": "equal operation is defined as a subclass of dyadic comparison operation. This class represents operations that perform a comparison between two entities and evaluate whether they are equal. As a refinement of dyadic comparison operation, equal operation specifically focuses on checking and indicating equality between two operands or values."}
{"class": "in order operation", "description": "in order operation is defined as a subclass of dyadic comparison operation, indicating that it represents a specific type of comparison involving two entities. As a specialized comparison operation, in order operation inherits all characteristics of dyadic comparison operations but further constrains its meaning to those operations that assess or evaluate entities with respect to their sequence or ordering."}
{"class": "isEmpty operation", "description": "isEmpty operation is defined as a subclass of boolean operation. This indicates that it represents a type of boolean operation, specifically one that evaluates a condition and returns a boolean value. No further restrictions or characteristics are provided by the axiom, so its primary purpose within the ontology is to serve as a specialized form of boolean operation."}
{"class": "nonNegative operation", "description": "nonNegative operation is a subclass of boolean operation. Any instance of nonNegative operation is, by definition, a type of boolean operation, inheriting all related properties and constraints. This classification indicates that nonNegative operation participates in logical or truth-value manipulations typical of boolean operations, but may have additional distinguishing characteristics defined outside of the given axioms."}
{"class": "SetOf:set", "description": "SetOf:set is defined as a subclass of boolean operation, indicating that it represents a form of operation consistent with the principles of Boolean logic. Members of this class inherit properties and constraints applicable to boolean operations. No further description is provided, so the class is formally understood as a type of boolean operation."}
{"class": "negate operation", "description": "negate operation is defined as a subclass of monadic operation, meaning it represents an operation that acts on a single operand. As a monadic operation, negate operation typically involves transforming or inverting the value of its sole input."}
{"class": "promote operation", "description": "promote operation is classified as a subclass of monadic operation. This indicates that promote operation is an operation involving a single operand or argument, inheriting all characteristics associated with monadic operations. No further distinguishing features or constraints are specified beyond its classification within this hierarchy."}
{"class": "serialize operation", "description": "serialize operation is defined as a subclass of monadic operation. This means every serialize operation is, by definition, a type of monadic operation, inheriting its general behaviors and properties. There are no additional restrictions or relationships specified."}
{"class": "successor operation", "description": "successor operation is defined as a subclass of monadic operation. This means that every successor operation is a type of operation that acts on a single argument. No additional restrictions or characteristics are specified, so the class inherits all properties of monadic operations."}
{"class": "Cast:choice", "description": "Cast:choice is defined as a subclass of monadic operation, indicating that it inherits all characteristics of monadic operations. This classification ensures that any instance of Cast:choice is considered a specific type of monadic operation, although further distinguishing properties or restrictions are not specified in the given axioms or description."}
{"class": "Dereference:pointer", "description": "Dereference:pointer is defined as a subclass of monadic operation. This means it represents a specific kind of monadic operation, typically referring to an action that takes a single operand and retrieves the value or object being pointed to by a pointer. Individuals of this class inherently possess the characteristics and constraints of monadic operations."}
{"class": "Discriminant:choice", "description": "Discriminant:choice is defined as a subclass of monadic operation, indicating that it represents a specific type of operation that acts upon a single operand or input. No further restrictions or disjointness axioms are specified, so it inherits all characteristics of monadic operation while introducing the notion of 'choice' as its distinguishing feature."}
{"class": "Extend:time&date", "description": "Extend:time&date is defined as a subclass of monadic operation, indicating that it represents a single-argument operation within the ontology. No further restrictions or characteristics are specified beyond its placement in the class hierarchy as a specialized form of monadic operation."}
{"class": "Invoke:procedure", "description": "Invoke:procedure is defined as a subclass of monadic operation, indicating that it represents a specific type of operation with a single argument or operand. This classification situates Invoke:procedure within the hierarchy of operations, emphasizing its functionality as a specialized, unary process. No further restrictions or disjoint relationships are specified."}
{"class": "Not:boolean", "description": "Not:boolean is defined as a subclass of monadic operation, indicating that it is a single-argument logical operation. Members of this class represent logical operations that act on one boolean input to produce a boolean output, specifically performing logical negation."}
{"class": "monadic aritmetic operation", "description": "monadic arithmetic operation is defined as a subclass of monadic operation. This means any instance of this class is a monadic operation (an operation with a single operand) specifically within the domain of arithmetic. It inherits all characteristics of monadic operations, restricted to those that perform arithmetic functions. No additional distinguishing axioms or constraints are currently specified."}
{"class": "monadic retrive operation", "description": "monadic retrieve operation is defined as a subclass of monadic operation. This means every monadic retrieve operation is a type of monadic operation, inheriting all its characteristics. No further property or restriction axioms are specified, so its definition is limited to this hierarchical relationship."}
{"class": "map operation", "description": "map operation is defined as a subclass of monadic operation. This indicates that every map operation is itself a type of monadic operation, inheriting its general properties. The map operation typically represents an action that applies a given function to each element within a structure (such as a list, set, or collection), producing a new structure of the same form with the results. No additional constraints or disjointness axioms are specified."}
{"class": "boolean operation", "description": "boolean operation is defined as a subclass of monadic operation. This indicates that every boolean operation is a kind of monadic operation, typically involving a single argument and producing a boolean output (true or false). The class encompasses operations that act on one operand and yield a binary (boolean) result."}
{"class": "reciprocial operation", "description": "reciprocal operation is formally defined as a subclass of monadic arithmetic operation, meaning it is an arithmetic operation that acts on a single operand. This class captures operations whose primary purpose is to return the multiplicative inverse (reciprocal) of their input value."}
{"class": "round operation", "description": "round operation is defined as a subclass of monadic arithmetic operation. This means every round operation acts on a single numerical input to produce its output, characterizing it as a unary arithmetic process, such as rounding a number to the nearest integer."}
{"class": "SquareRoot:complex", "description": "SquareRoot:complex is defined as a subclass of monadic arithmetic operation, indicating that it represents an arithmetic operation involving only one operand (monadic) in the context of complex numbers. This class formalizes the concept of computing the square root specifically within the domain of complex arithmetic."}
{"class": "monadic select operation", "description": "monadic select operation is defined as a subclass of monadic retrieve operation. This means every monadic select operation is a type of monadic retrieve operation, inheriting its essential characteristics. No additional property restrictions or disjointness constraints are specified; thus, its definition is strictly as a specialized form of monadic retrieve operation with no further distinguishing axioms."}
{"class": "AttributeFunctionInvocation:class", "description": "AttributeFunctionInvocation:class is defined as a subclass of monadic retrieve operation. This indicates that any instance of AttributeFunctionInvocation:class inherits the characteristics of a monadic retrieve operation, meaning it represents an operation that retrieves a value based on a single operand or argument. The class is intended to capture invocations related to retrieving attributes in a functional, monadic manner."}
{"class": "AttributeSelect:class", "description": "AttributeSelect:class is defined as a subclass of monadic retrieve operation. This means that any instance of AttributeSelect:class represents a specific type of retrieval operation that acts on a single operand to extract or select an attribute. By inheriting from monadic retrieve operation, AttributeSelect:class is characterized by supporting retrieval actions that involve one input and are focused on obtaining attribute-level data."}
{"class": "FieldSelect:record", "description": "FieldSelect:record is defined as a subclass of monadic retrieve operation, meaning it represents a specialized form of retrieval operation within a monadic (single-argument or single-result) context. No additional restrictions or properties are specified, so any instance of FieldSelect:record is also an instance of monadic retrieve operation, inheriting all its characteristics."}
{"class": "Head:sequence", "description": "Head:sequence is defined as a subclass of monadic retrieve operation. This means that every instance of Head:sequence is also considered a monadic retrieve operation, inheriting its fundamental characteristics and constraints. The class does not specify additional axioms or restrictions beyond this hierarchical relationship."}
{"class": "Tail:sequence", "description": "Tail:sequence is defined as a subclass of monadic retrieve operation. This classification means that any individual instance of Tail:sequence is also a type of monadic retrieve operation, inheriting its foundational characteristics. In the absence of further description or additional axioms, Tail:sequence is interpreted as a specific kind of retrieval operation within a monadic context, implying it operates under the rules and structure of monads\u2014commonly used in functional programming and computational logic for chaining operations."}
{"class": "countable", "description": "countable is defined as a subclass of cardinality, indicating that it represents a specific type of cardinality. Members of the countable class are characterized by having a cardinality that can be matched with the set of natural numbers, distinguishing them from other forms of cardinality."}
{"class": "finite", "description": "finite is a subclass of cardinality, indicating that it represents the concept of cardinalities that are limited or bounded. Any individual classified as finite is, by definition, also a cardinality but with the additional constraint that its size is not infinite."}
{"class": "uncountable", "description": "uncountable is defined as a subclass of cardinality, indicating that it represents a specific type of cardinality. Members of the uncountable class are those cardinalities that cannot be placed into a one-to-one correspondence with the natural numbers, distinguishing them from countable cardinalities."}
{"class": "bounded above", "description": "bounded above is defined as a subclass of bounded, representing objects or sets that possess an upper bound. It is explicitly disjoint with bounded below, ensuring no individual can simultaneously be both bounded above and bounded below. This means any member of this class is characterized by having an upper bound but not a lower bound within the context of the ontology."}
{"class": "bounded below", "description": "bounded below is a subclass of bounded, representing entities that possess the property of being bounded in a particular way\u2014specifically, from below. Any member of bounded below is, by definition, also a member of bounded."}
{"class": "unbounded above", "description": "unbounded above is defined as a subclass of unbounded, representing entities that do not have an upper bound. It is explicitly disjoint with unbounded below, ensuring that no individual can simultaneously be both unbounded above and unbounded below. This class characterizes those entities that lack an upper limit but may or may not have a lower bound."}
{"class": "unbounded below", "description": "unbounded below is defined as a subclass of unbounded, meaning every instance of unbounded below is also an instance of unbounded. This class represents entities that specifically possess the characteristic of being unbounded on their lower side or extent, while inheriting all properties and restrictions from the broader unbounded class."}
{"class": "bounded", "description": "bounded is defined as a subclass of boundedness, representing entities that possess the property of being bounded. It is explicitly disjoint with unbounded, ensuring that no individual can be simultaneously classified as both bounded and unbounded. This classification enforces a strict separation between bounded and unbounded entities within the ontology."}
{"class": "unbounded", "description": "unbounded is defined as a subclass of boundedness. This indicates that unbounded is a specific type or form of boundedness, and any instance of unbounded is also considered an instance of boundedness. No additional property restrictions or disjointness axioms are specified, so the class is distinguished solely by its hierarchical relation."}
{"class": "approximate", "description": "approximate is defined as a subclass of exactness, meaning it represents a kind or degree of exactness. It is explicitly disjoint with exact, so no individual can simultaneously be both approximate and exact. This class formalizes the notion of approximation as distinct from strict exactness within the ontology."}
{"class": "exact", "description": "exact is defined as a subclass of exactness, indicating that any instance of exact exhibits all characteristics associated with exactness. No additional constraints or distinguishing axioms are specified for this class."}
{"class": "numeric", "description": "numeric is defined as a subclass of numericalness, representing entities characterized by having numerical properties. It is explicitly disjoint with non-numeric, ensuring that no individual can simultaneously belong to both numeric and non-numeric classes. This formalization distinguishes numeric entities, which possess quantifiable or number-based characteristics, from those lacking such numerical nature."}
{"class": "non-numeric", "description": "non-numeric is defined as a subclass of numericalness, indicating that every instance of non-numeric falls under the broader concept of numericalness. This class is intended to capture entities that are related to numericalness but are explicitly characterized by the absence of numeric value or representation."}
{"class": "ordered", "description": "ordered is defined as a subclass of order, indicating that all instances of ordered are also considered orders according to the ontology. It is explicitly disjoint with non-ordered, meaning that no individual can be simultaneously classified as both ordered and non-ordered. This formalization distinguishes entities that possess or exhibit ordering from those that do not."}
{"class": "non-ordered", "description": "non-ordered is defined as a subclass of order. This means that every instance of non-ordered is also an instance of order, but represents a specialized form or category within the broader concept of order. No additional property restrictions or disjointness axioms are specified, so the class is distinguished solely by its hierarchical position as a subclass."}
{"class": "Add:complex", "description": "Add:complex is defined as a subclass of add operation, indicating that it represents a specific form of addition within the broader category of add operations. This formalization establishes that every instance of add:complex is also inherently an add operation, possibly specialized for use with complex numbers or structures, depending on further specification."}
{"class": "Add:integer", "description": "Add:integer is defined as a subclass of add operation, indicating that it specifically represents addition operations where the operands are integers. Any individual that is an instance of Add:integer is inherently an add operation, but specialized for use with integer values."}
{"class": "Add:rational", "description": "Add:rational is defined as a subclass of add operation, indicating that it represents a specialized type of addition focused on rational numbers. This class inherits all characteristics of add operations and is formally distinguished as pertaining to the addition of rational values."}
{"class": "Add:real", "description": "Add:real is defined as a subclass of add operation. This means that every instance of Add:real is an add operation, specifically focused on real numbers. The class inherits all the characteristics of generic add operations, but may specify additional constraints or behaviors relevant to addition in the domain of real numbers. No further restrictions or disjointness axioms are asserted."}
{"class": "Add:scaled", "description": "scaled is defined as a subclass of add operation. This means that any scaled operation is recognized as a specific type of add operation, inheriting all characteristics of add operations while potentially introducing its own specialized behavior or constraints. No further disjointness or property restrictions are specified for this class."}
{"class": "Delete:bag", "description": "Delete:bag is defined as a subclass of delete operation, indicating that it represents a specific type of deletion action. It is also explicitly disjoint with Delete:table, ensuring that no individual can be both a Delete:bag and a Delete:table operation. This formalization distinguishes Delete:bag as a unique deletion process within the ontology, separate from deletion operations targeting tables."}
{"class": "Delete:table", "description": "Delete:table is defined as a subclass of delete operation. This means that every instance of Delete:table is a specific type of delete operation, inheriting all characteristics of delete operations, and representing deletion actions applied at the table level."}
{"class": "Difference:set", "description": "Difference:set is defined as a subclass of the difference operation, representing the set-theoretic difference between collections or sets. It is explicitly disjoint with Difference:time&date, so no instance can be both a set difference and a time/date difference. This class captures operations or results concerning the removal of elements from one set that exist in another, and is restricted to set-based contexts."}
{"class": "Difference:time&date", "description": "Difference:time&date is defined as a subclass of difference operation. This class represents operations specifically focused on calculating the difference between temporal values such as times or dates, distinguishing it from other types of difference operations. Members of this class inherit all properties and constraints associated with difference operations, but are restricted to application within time and date contexts."}
{"class": "Select:array", "description": "Select:array is defined as a subclass of dyadic select operation, indicating it is a specific kind of select operation involving two operands. It is explicitly disjoint with Select:table, ensuring no individual can be both a Select:array and a Select:table. This class is used to represent select operations that specifically operate on array data structures, and not on tables."}
{"class": "Select:table", "description": "Select:table is defined as a subclass of dyadic select operation, indicating that it represents a specific type of select operation involving two inputs or components. This class inherits all the characteristics and constraints of dyadic select operations, and any instance of Select:table is, by definition, also an instance of a dyadic select operation. No additional restrictions or disjointness axioms are specified."}
{"class": "Equal:array", "description": "Equal:array is defined as a subclass of equal operation. This means Equal:array represents a specific type of equality operation, typically involving arrays, and inherits all the general characteristics of equal operations. No additional property restrictions or disjointness axioms are specified."}
{"class": "Equal:bag", "description": "Equal:bag is defined as a subclass of equal operation, indicating that it represents a specific type of equality evaluation or operation. Any instance of Equal:bag inherits all characteristics of equal operation, positioning it within the broader context of equality comparisons. There are currently no additional restrictions or disjointness axioms specified for this class."}
{"class": "Equal:boolean", "description": "Equal:boolean is a subclass of equal operation, representing operations that specifically check or enforce equality between two boolean values. Any individual of this class is an instance of an equal operation, with its domain restricted to boolean-type operands."}
{"class": "Equal:character", "description": "Equal:character is defined as a subclass of equal operation. This means every instance of Equal:character represents a specific kind of equality operation, likely focused on comparing characters. Since it inherits all characteristics of equal operation, Equal:character is used where character equality checks are required."}
{"class": "Equal:choice", "description": "Equal:choice is a subclass of equal operation, indicating that each instance of Equal:choice is a specialized form of equal operation. No additional restrictions, disjointness, or property constraints are defined for this class, so its characterization is derived solely from its position in the class hierarchy."}
{"class": "Equal:class", "description": "Equal:class is defined as a subclass of equal operation, indicating that every instance of Equal:class is a specific type of equal operation. This formalization ensures that any individual classified as Equal:class must also satisfy the properties and constraints of equal operations within the ontology."}
{"class": "Equal:complex", "description": "Equal:complex is defined as a subclass of equal operation. This means that every instance classified as Equal:complex is, by definition, also an instance of equal operation. No further distinguishing axioms or restrictions are specified for this class beyond its hierarchical placement."}
{"class": "Equal:enumerated", "description": "Equal:enumerated is defined as a subclass of equal operation. This indicates that every instance of Equal:enumerated represents a specific kind of equal operation, inheriting all characteristics of equal operation while potentially introducing further constraints or properties relevant to enumerated equality."}
{"class": "Equal:integer", "description": "Equal:integer is defined as a subclass of equal operation, indicating that it represents a specialized type of equality operation specifically applied to integers. Any instance of Equal:integer is inherently an equal operation, but it is characterized by its restriction to operands of the integer type."}
{"class": "Equal:ordinal", "description": "Equal:ordinal is defined as a subclass of equal operation, indicating that it specifically represents equality operations within the context of ordinal numbers or positions. Instances of this class inherit all properties of equal operations but are semantically restricted to comparisons involving ordinality."}
{"class": "Equal:pointer", "description": "Equal:pointer is defined as a subclass of equal operation. This means it inherits all characteristics of an equal operation and represents a specific form or type of equality operation within the ontology. There are no further restrictions or differentiating axioms provided, so it can be broadly understood as any equality operation that is categorized or implemented as a \"pointer.\""}
{"class": "Equal:procedure", "description": "Equal:procedure is defined as a subclass of equal operation, indicating that it represents a specific type of equal operation. All instances of Equal:procedure inherit the characteristics and constraints of equal operations. No additional restrictions or properties are specified beyond this subclass relationship."}
{"class": "Equal:rational", "description": "Equal:rational is defined as a subclass of equal operation. This means every instance of Equal:rational is also an instance of equal operation, inheriting its properties and characteristics. This class specifically represents the application of equality within the context of rational values, distinguishing it from other types of equal operations."}
{"class": "Equal:real", "description": "Equal:real is defined as a subclass of equal operation, representing equality operations that specifically pertain to real numbers. Any instance of Equal:real is an equal operation, and this class captures the concept of evaluating or asserting equality within the domain of real numbers."}
{"class": "Equal:record", "description": "Equal:record is defined as a subclass of equal operation, indicating that it represents a specialized form of comparison operation focused on evaluating equality. All instances of Equal:record inherit the characteristics and constraints associated with equal operations."}
{"class": "Equal:scaled", "description": "Equal:scaled is defined as a subclass of equal operation, meaning it inherits all characteristics of equal operations. This class represents a specific type of equal operation, but is further specialized under the general category of equality operations. There are no additional restrictions or disjointness axioms specified."}
{"class": "Equal:sequence", "description": "Equal:sequence is defined as a subclass of equal operation, indicating that it represents a specific type of equality operation. Any instance of Equal:sequence is thus an equal operation, inheriting its general characteristics and semantic constraints. No additional restrictions or disjointness axioms are specified, so its primary distinguishing feature is its specialization within the equal operation hierarchy."}
{"class": "Equal:set", "description": "Equal:set is defined as a subclass of equal operation. This means that every instance of Equal:set is a type of equal operation, inheriting all characteristics and properties of equal operations. No further constraints or disjointness are specified, so its primary ontological role is to represent a specific kind or subset of equal operations."}
{"class": "Equal:discrete", "description": "Equal:discrete is a subclass of equal operation, representing a specific type of equality operation within the ontology. Any instance classified as Equal:discrete inherently possesses all characteristics of equal operation, but denotes a discrete (distinct and separate) form of equality as opposed to potentially other forms covered under the broader parent class."}
{"class": "Equal:table", "description": "Equal:table is defined as a subclass of equal operation, indicating that it represents a specific type of equal operation within the ontology. There are no further restrictions or disjointness axioms provided, so its characteristics are inherited entirely from equal operation. This formalization ensures that every instance of Equal:table is also considered an instance of equal operation."}
{"class": "Equal:time&date", "description": "Equal:time&date is defined as a subclass of equal operation. This class represents equality operations specifically applied to time and date values, inheriting all characteristics of general equal operations while restricting its domain to temporal data. There are no additional property restrictions or disjointness axioms specified."}
{"class": "Equal:void", "description": "Equal:void is defined as a subclass of equal operation, indicating that it represents a specific type of equality operation within the ontology. Instances of Equal:void inherit all characteristics of equal operation but are further specialized to reflect this subclass distinction. No additional constraints or property restrictions are present."}
{"class": "InOrder:enumerated", "description": "InOrder:enumerated is defined as a subclass of in order operation. This indicates that it inherits all characteristics of in order operations, and further restricts its members to those specifically classified as InOrder:enumerated. No additional disjointness or property restrictions are specified."}
{"class": "InOrder:interger", "description": "InOrder:integer is defined as a subclass of in order operation. This means every instance of InOrder:integer is also an instance of in order operation, inheriting its properties and characteristics. No additional restrictions or properties are specified."}
{"class": "InOrder:ordinal", "description": "InOrder:ordinal is defined as a subclass of in order operation, meaning every instance of InOrder:ordinal is also an instance of in order operation. This class captures operations that are performed in a specific, sequential order, consistent with the broader concept of ordered computational procedures."}
{"class": "InOrder:rational", "description": "InOrder:rational is defined as a subclass of in order operation. This means every instance of InOrder:rational is also an instance of in order operation, inheriting its essential properties and behavioral constraints. There are currently no additional property restrictions or disjointness axioms specified for this class, so its definition is primarily characterized by its position within the hierarchy of ordered operations."}
{"class": "InOrder:real", "description": "InOrder:real is defined as a subclass of in order operation. This means that every instance of InOrder:real is necessarily an in order operation, inheriting all characteristics and constraints of its parent class. No further distinguishing features or restrictions are specified in the current axiom."}
{"class": "InOrder:scaled", "description": "InOrder:scaled is defined as a subclass of in order operation, indicating that it represents a specialized type of in order operation. No additional property restrictions or disjointness axioms are specified for this class."}
{"class": "InOrder:time&date", "description": "InOrder:time&date is defined as a subclass of in order operation. This means that every instance of InOrder:time&date is also an instance of in order operation, inheriting all its characteristics and constraints. The class represents a specific type of in order operation that is distinguished within the ontology for handling operations related to time and date."}
{"class": "Insert:bag", "description": "Insert:bag is defined as a subclass of insert operation, signifying that it represents a specific type of insertion action. It is declared disjoint with Insert:table, which means that an instance of Insert:bag cannot simultaneously belong to the Insert:table class. This distinction enforces mutual exclusivity between these two types of insertion operations."}
{"class": "Insert:table", "description": "Insert:table is defined as a subclass of insert operation, representing a specialized form of data insertion that specifically targets tables. Any individual of Insert:table is by definition an insert operation, but this class serves to distinguish insert actions that are restricted to table-type data structures."}
{"class": "Multiply:complex", "description": "Multiply:complex is defined as a subclass of multiply operation, indicating that it represents a specialized form of multiplication specifically applicable to certain contexts (such as complex numbers or more advanced multiplicative structures). As a subclass, all characteristics and constraints of multiply operation apply, while distinguishing multiply:complex as a distinct category within the overall multiplication framework. No additional property restrictions or disjointness axioms are specified."}
{"class": "Multiply:integer", "description": "Multiply:integer is defined as a subclass of multiply operation. This class represents multiplication operations specifically involving integer values, inheriting all properties and constraints of general multiplication operations but restricted to the integer domain."}
{"class": "Multiply:rational", "description": "Multiply:rational is a subclass of multiply operation. This class represents multiplication operations where the operands are specifically rational numbers, distinguishing it from multiply operations over other numeric domains."}
{"class": "Multiply:real", "description": "Multiply:real is defined as a subclass of multiply operation, indicating that it represents multiplication specifically within the domain of real numbers. Any instance of Multiply:real inherits the characteristics and constraints of the general multiply operation, but is restricted in application to real-valued operands."}
{"class": "Multiply:scaled", "description": "Multiply:scaled is defined as a subclass of multiply operation. This indicates that it inherits all characteristics of multiply operations while representing a more specific variant or context of multiplication. No additional restrictions or disjointness axioms are specified. Without a current description, its identity is determined solely by its position in the class hierarchy, denoting a specialized type of multiplication operation."}
{"class": "And:boolean", "description": "And:boolean is defined as a subclass of dyadic logical operation, indicating that it is a logical operation involving two operands. This class represents the AND operation, commonly used in logic to yield true only when both input values are true."}
{"class": "Or:boolean", "description": "Or:boolean is defined as a subclass of dyadic logical operation, representing a logical operation that takes two inputs. It corresponds to the Boolean \"or\" operation, where the result is true if at least one of the inputs is true. Members of this class are restricted to binary (dyadic) logic functions operating under the inclusive disjunction principle."}
{"class": "Fetch:table", "description": "Fetch:table is defined as a subclass of dyadic retrieve operation, indicating that it represents a specific type of retrieve action that involves two entities. As a specialized dyadic retrieve operation, Fetch:table inherits all the relevant characteristics of such operations within the ontology, distinguishing it from other forms of retrieval actions."}
{"class": "Tag:choice", "description": "Tag:choice is defined as a subclass of dyadic retrieve operation, indicating that it represents a specific retrieval action involving two inputs or arguments. This class is thus characterized by its relation to operations that retrieve or select information based on two distinct pieces of input, inheriting all properties and restrictions applicable to dyadic retrieve operations."}
{"class": "Intersection:set", "description": "Intersection:set is defined as a subclass of dyadic set operation, signifying that it operates on two sets. This class represents the set operation that yields a set containing all elements that are common to both input sets. As a dyadic set operation, it explicitly requires two sets as operands and produces a new set consisting only of elements present in both."}
{"class": "Lsln:set", "description": "Lsln:set is formally defined as a subclass of dyadic set operation, indicating that it represents a type of operation involving two sets. No additional constraints or distinguishing characteristics are specified beyond its categorization under dyadic set operations."}
{"class": "Subset:set", "description": "Subset:set is defined as a subclass of dyadic set operation, which means it represents a specific type of set operation that involves two sets. Members of this class pertain to operations that determine whether one set is a subset of another, inheriting all formal properties of dyadic set operations."}
{"class": "Union:set", "description": "Union:set is defined as a subclass of dyadic set operation, indicating that it represents a type of set operation involving two sets. Members of this class perform the union operation, which combines all distinct elements from both input sets into a single set. This classification situates Union:set within the broader context of binary operations on sets."}
{"class": "IsEmpty:bag", "description": "IsEmpty:bag is defined as a subclass of isEmpty operation. This indicates that IsEmpty:bag represents a specific type of isEmpty operation applied to bags, distinguishing it from other isEmpty operations that may apply to different data structures. Any instance of IsEmpty:bag is necessarily an isEmpty operation, constrained in scope to the context of bags."}
{"class": "IsEmpty:sequence", "description": "IsEmpty:sequence is defined as a subclass of the isEmpty operation. This class represents operations that are specific forms of isEmpty, likely indicating procedures to determine whether a sequence is empty. By subclassing isEmpty operation, IsEmpty:sequence inherits all properties and constraints associated with isEmpty operations, but is further specialized to apply specifically to sequences."}
{"class": "IsEmpty:table", "description": "IsEmpty:table is defined as a subclass of the isEmpty operation. This means that it represents a specific isEmpty operation applied to tables, inheriting all general properties of isEmpty operations and specializing them for table data structures. Any instance of IsEmpty:table can be understood as an operation that checks or determines whether a table is empty."}
{"class": "Select:bag", "description": "Select:bag is defined as a subclass of monadic select operation, indicating that it represents a form of selection operation that applies to a single argument within a computational or logical context. It is explicitly disjoint with Select:set, ensuring that no instance can simultaneously be both a Select:bag and a Select:set. This conceptual separation enforces that Select:bag and Select:set represent fundamentally distinct kinds of select operations."}
{"class": "Select:set", "description": "Select:set is defined as a subclass of monadic select operation, indicating that it represents a specific type of selection operation that acts on a single input or operand. This formalization ensures that any instance of Select:set inherits the properties and constraints associated with monadic select operations. No further distinguishing characteristics or disjointness conditions are specified."}
{"class": "Negate:complex", "description": "Negate:complex is formally defined as a subclass of negate operation. This indicates that every instance of Negate:complex is a specific type of negate operation, inheriting all properties and constraints associated with negate operations. No additional distinguishing characteristics or property restrictions are specified at this level."}
{"class": "Negate:integer", "description": "Negate:integer is defined as a subclass of negate operation. This class represents the operation of taking an integer and producing its additive inverse (negation). Any instance of Negate:integer is a specific case of a negate operation, restricted to the integer domain."}
{"class": "Negate:rational", "description": "Negate:rational is defined as a subclass of negate operation. This class represents operations that perform negation specifically within the domain of rational numbers. Any instance of this class is considered a type of negate operation, formally representing the mathematical action of producing the additive inverse of a rational value."}
{"class": "Negate:real", "description": "Negate:real is defined as a subclass of the negate operation. This class represents the negation operation as specifically applied to real numbers, inheriting all constraints and characteristics of the more general negate operation category."}
{"class": "Negate:scaled", "description": "Negate:scaled is defined as a subclass of negate operation. This means that every instance of Negate:scaled is a specific type of negate operation, inheriting all properties and restrictions associated with negate operations. The class is intended to represent a specialized negation process, although additional characteristics would depend on further axioms or descriptions."}
{"class": "NonNegative:integer", "description": "NonNegative:integer is defined as a subclass of nonNegative operation, representing integers that are greater than or equal to zero. It is formally disjoint with NonNegative:rational, ensuring that no individual can be both a NonNegative:integer and a NonNegative:rational. This class captures the concept of all non-negative integer values, distinguishing them from non-negative rational numbers."}
{"class": "NonNegative:rational", "description": "NonNegative:rational is defined as a subclass of nonNegative operation. This means every instance of NonNegative:rational is also an instance of nonNegative operation, specifically representing rational values or operations constrained to non-negative results. The class formalizes the distinction between all nonNegative operations and those that pertain strictly to rational (i.e., fractional or whole number) non-negative values."}
{"class": "Promote:complex", "description": "Promote:complex is defined as a subclass of promote operation, indicating that every instance of Promote:complex is also an instance of promote operation. This class inherits all the properties and characteristics of promote operation, while potentially introducing additional specificity or constraints unique to Promote:complex."}
{"class": "Promote:rational", "description": "Promote:rational is defined as a subclass of the promote operation class. This indicates that every instance of Promote:rational is a specific type of promote operation, inheriting all general characteristics of promote operations. No further restrictions, disjointness, or additional axioms are specified for this class."}
{"class": "Promote:real", "description": "Promote:real is a subclass of promote operation, indicating that it represents a specialized form of promote operation within the ontology. Any individual classified as Promote:real inherits all characteristics and constraints associated with promote operation. No additional distinguishing axioms or restrictions are currently specified for this class."}
{"class": "Reciprocal:rational", "description": "Reciprocal:rational is defined as a subclass of reciprocal operation. This means every instance of Reciprocal:rational is a specific type of reciprocal operation, typically involving rational numbers. No additional property restrictions or disjointness axioms are specified, so members of this class inherit all general properties of reciprocal operations."}
{"class": "Reciprocal:real", "description": "Reciprocal:real is defined as a subclass of reciprocal operation. This class represents the operation of finding the reciprocal specifically within the domain of real numbers. Any instance of Reciprocal:real is a kind of reciprocal operation applied to real numbers."}
{"class": "Reciprocal:complex", "description": "Reciprocal:complex is defined as a subclass of reciprocal operation. This means every instance of Reciprocal:complex is also a reciprocal operation. The class is characterized by operations that involve computing the reciprocal (multiplicative inverse) specifically within the context of complex numbers."}
{"class": "Round:scaled", "description": "Round:scaled is defined as a subclass of round operation, and it is explicitly disjoint with Round:time&date, meaning no entity can be an instance of both classes simultaneously. Members of the Round:scaled class represent rounding operations that are specifically not applicable to time or date values, but instead pertain to other types of values handled in scaled or quantitative contexts."}
{"class": "Round:time&date", "description": "Round:time&date is defined as a subclass of round operation. This means that all instances of Round:time&date are specific types of rounding operations that pertain to time and date values. The class captures rounding processes as applied to temporal data, inheriting all general properties of round operations."}
{"class": "Serialize:bag", "description": "Serialize:bag is defined as a subclass of serialize operation, representing a specific type of serialization process. It is explicitly disjoint with Serialize:table, ensuring that no instance can be classified as both Serialize:bag and Serialize:table. This distinction enforces separation between bag-based and table-based serialization methods."}
{"class": "Serialize:table", "description": "Serialize:table is defined as a subclass of serialize operation. This indicates that it represents a specific type of serialization process, inheriting all characteristics of a serialize operation but further specializing to handle table data structures. Any individual of Serialize:table is, by axiom, a serialize operation specifically concerned with tables."}
{"class": "Successor:enumerated", "description": "Successor:enumerated is defined as a subclass of the successor operation, indicating it represents a specific type or aspect of the successor process. It is explicitly disjoint with Successor:ordinal, which formally ensures that no individual can be both a member of Successor:enumerated and Successor:ordinal simultaneously. This separation captures distinct interpretations or instances of successor within the relevant domain."}
{"class": "Successor:ordinal", "description": "Successor:ordinal is a subclass of successor operation, representing those operations specifically associated with generating the next ordinal in a well-ordered sequence. Members of this class perform the function of yielding the immediate successor ordinal, as formalized within the framework of ordinal arithmetic."}
{"class": "MapToBag:table", "description": "MapToBag:table is a subclass of map operation, representing a specific type of mapping operation. This class inherits all characteristics of map operations and specifies entities that perform mapping tasks in a tabular context."}
{"class": "MapToTable:table", "description": "MapToTable:table is defined as a subclass of map operation, indicating that it inherits all characteristics of map operations. This class represents a specific type of mapping process with the intended outcome or function directly associated with tables. Individuals of this class are specialized map operations that result in or involve tables as part of their output or transformation."}
{"class": "Replace:array", "description": "Replace:array is defined as a subclass of n-adic operation, signifying that it represents an operation which can take an arbitrary number of arguments. Individuals of this class inherit all properties and constraints associated with n-adic operations, and the class serves to specify operations that involve the replacement of elements within arrays or similar data structures. No further characteristics or constraints are specified beyond its position in the class hierarchy."}
{"class": "Empty:bag", "description": "Empty:bag is defined as a subclass of niladic operation, indicating that it represents an operation which does not require any arguments or inputs. This class models entities or operations that, by their formal definition, do not take parameters."}
{"class": "Empty:sequence", "description": "Empty:sequence is defined as a subclass of niladic operation, indicating that it represents a special operation that does not take any arguments or inputs. This class characterizes sequences that are inherently empty and do not exhibit any elements or content, consistent with the semantics of niladic operations in formal systems."}
{"class": "Empty:set", "description": "Empty:set is defined as a subclass of niladic operation. This means that an empty set inherits all characteristics of niladic operations, which are operations that do not require any operands. The classification suggests that empty:set is conceptualized in an operational framework where no input or elements are involved."}
{"class": "Empty:table", "description": "Empty:table is defined as a subclass of niladic operation, indicating that it represents an operation or entity that does not take any input arguments. As a specific type of niladic operation, Empty:table is characterized by being an operation without operands, typically used to denote or construct an empty table structure within its context."}
{"class": "index access", "description": "index access is defined as a subclass of direct access property and is explicitly disjoint with key access, meaning an individual cannot be both an index access and a key access. This class represents mechanisms or operations that permit direct access to elements based on their positional index within a collection, distinctly separating it from access methods based on explicit keys."}
{"class": "key access", "description": "key access is defined as a subclass of direct access property, meaning it inherits all characteristics of direct access property while representing a more specific type. Members of the key access class pertain to properties or relationships that enable or characterize direct forms of access, distinguished from other access mechanisms by their explicit subclass designation."}
{"class": "access by value", "description": "access by value is defined as a subclass of indirect access property, indicating that it represents a specific type of indirect access. Any individual classified as access by value inherits all the characteristics of indirect access property, typically referring to situations where access is achieved through the value rather than the reference or pointer itself."}
{"class": "implementation dependent access", "description": "implementation dependent access is defined as a subclass of indirect access property, indicating that it inherits all characteristics of indirect access property. This means any instance of implementation dependent access is also considered an indirect access property, but with specific details or constraints determined by the particular implementation. There is no further specification beyond its placement in the class hierarchy."}
{"class": "position access", "description": "position access is defined as a subclass of indirect access property, indicating that it represents a type of access property that is not direct but mediated through some intermediary or reference. All instances of position access therefore inherit the characteristics and constraints associated with indirect access property."}
{"class": "ordered aggregate", "description": "ordered aggregate is defined as a subclass of aggregate imposed ordering, meaning it inherits all properties of aggregates that have a specific ordering structure. It is explicitly disjoint with unordered aggregate, indicating that no individual can simultaneously be both an ordered and an unordered aggregate. This formalization captures the distinction between collections with an inherent order and those without, ensuring that ordered aggregates maintain a structured sequence among their elements."}
{"class": "unordered aggregate", "description": "unordered aggregate is a subclass of aggregate imposed ordering. This means every unordered aggregate is an aggregate where some ordering has been considered, but specifically, unordered aggregate refers to those aggregates where the order of the constituents is irrelevant or not specified. No additional disjointness or property restrictions are defined."}
{"class": "identifier not unique", "description": "identifier not unique is a subclass of aggregate-imposed identifier uniqueness and is disjoint with identifier unique, meaning no individual can simultaneously be both identifier not unique and identifier unique. This class represents identifiers within an aggregate context that are not required to be unique, distinguishing them from identifiers that have enforced uniqueness at the aggregate level."}
{"class": "identifier unique", "description": "identifier unique is defined as a subclass of aggregate-imposed identifier uniqueness. This indicates that any individual or instance of identifier unique inherits all properties and constraints of aggregate-imposed identifier uniqueness, implying that the uniqueness of identifiers is imposed at the aggregate level. Without additional description, this class specifically represents entities for which unique identification is ensured by aggregate-imposed mechanisms."}
{"class": "fixed size", "description": "fixed size is defined as a subclass of aggregate size, representing a type of size where the measurement remains constant. It is explicitly disjoint with variable size, indicating that no entity can simultaneously be considered both fixed size and variable size. This ensures that fixed size aggregates maintain a consistent value and cannot change over time or context."}
{"class": "variable size", "description": "variable size is defined as a subclass of aggregate size. This specifies that any instance of variable size is also an instance of aggregate size, inheriting all its properties and restrictions. No further distinguishing characteristics or disjointness constraints are specified for variable size beyond its hierarchical relationship."}
{"class": "component mandatory", "description": "component mandatory is defined as a subclass of component mandatoriness and is explicitly disjoint with component non-mandatory, ensuring that no individual can simultaneously be both a component mandatory and component non-mandatory. This class characterizes components that are required or obligatory within a given context, distinguishing them from non-mandatory components."}
{"class": "component non-mandatory", "description": "component non-mandatory is defined as a subclass of component mandatoriness. This classification indicates that component non-mandatory represents components characterized by a specific mandatoriness status, distinguishing them from other types of component mandatoriness. No further restrictions or disjointness axioms are specified for this class."}
{"class": "one dimensional", "description": "one dimensional is defined as a subclass of dimensionality. This class represents entities or concepts that possess exactly one dimension, distinguishing them from higher-dimensional counterparts. Any individual classified as one dimensional must inherently exhibit characteristics specific to single-dimensionality."}
{"class": "two dimensional", "description": "two dimensional is defined as a subclass of dimensionality. This class represents entities or concepts characterized specifically by having two dimensions (such as length and width), distinguishing them within the broader category of dimensionality."}
{"class": "multi dimensional", "description": "multi dimensional is defined as a subclass of dimensionality, meaning it represents a specific type or instance within the broader concept of dimensionality. Any entity classified as multi dimensional inherently possesses the quality of having multiple dimensions, as specified by its placement under the dimensionality hierarchy."}
{"class": "homogenous", "description": "homogenous is defined as a subclass of homogenity, indicating that all instances of this class exhibit uniformity in composition or character. It is explicitly disjoint with heterogenous\u2014no individual can be both homogenous and heterogenous\u2014ensuring a clear distinction between classes characterized by uniformity and those characterized by diversity."}
{"class": "heterogenous", "description": "heterogenous is defined as a subclass of homogenity. This means every heterogenous entity is considered a type of homogenity, establishing a hierarchical relationship in which heterogenous inherits all characteristics of homogenity; however, further distinctions or defining properties are not specified by the current axioms or descriptions."}
{"class": "recursive", "description": "recursive is defined as a subclass of recursiveness, signifying that every instance of recursive inherits properties from recursiveness. It is explicitly disjoint with non-recursive, ensuring that no individual can simultaneously belong to both recursive and non-recursive classes. This formalization distinguishes all recursive instances from those that are non-recursive."}
{"class": "non-recursive", "description": "non-recursive is defined as a subclass of recursiveness, meaning every non-recursive entity is a specific type of recursiveness. This class represents elements that, while related to the broader concept of recursiveness, possess characteristics that distinguish them as non-recursive within that context."}
{"class": "structured", "description": "structured is defined as a subclass of structurness. This indicates that every instance of structured also inherits all characteristics and constraints of structurness. No further properties or restrictions are specified for this class."}
{"class": "unstructured", "description": "unstructured is defined as a subclass of structurness. This means that every instance of unstructured is also an instance of structurness, inheriting all properties and constraints applicable to structurness. There are no additional property restrictions or disjointness axioms specified for this class."}
{"class": "semi-structured", "description": "semi-structured is defined as a subclass of structurness. This means that every instance of semi-structured is also an instance of structurness, inheriting its general properties while specializing or refining its concept. No additional property restrictions or disjointness axioms are specified, so the class is characterized primarily by its placement within the structurness hierarchy."}
{"class": "non-unique values", "description": "non-unique values is defined as a subclass of uniqueness, but is explicitly disjoint with unique values, meaning no instance can be both a non-unique value and a unique value. This class captures those values that do not fulfill the criteria for uniqueness within a given context, thereby representing data elements that may have duplicates or repeated entries within a dataset or collection."}
{"class": "unique values", "description": "unique values is defined as a subclass of uniqueness, indicating that every instance of unique values is also an instance of uniqueness. This classification implies that members of this class represent values that are distinguished by not being duplicated within a given context, enforcing a guarantee of singularity for each value."}
{"class": "descriptive field identifier", "description": "descriptive field identifier is a subclass of field identifier, and is explicitly disjoint with target field identifier, meaning that no individual can simultaneously be both a descriptive field identifier and a target field identifier. This class represents identifiers that have descriptive purposes, distinguishing them from identifiers that serve as targets. The disjointness axiom enforces a clear conceptual separation between descriptive and target field identifiers within the ontology."}
{"class": "target field identifier", "description": "target field identifier is defined as a subclass of field identifier. This means that every target field identifier is a specialized form of field identifier and inherits all its properties and constraints. No additional axioms or distinguishing properties are specified for this class."}
{"class": "target primitive field component", "description": "target primitive field component is defined as a subclass of labeled dataset target field component, specializing the notion of dataset fields that serve as targets in labeled datasets. Individuals in this class must play the role of some real, discrete, or boolean datatype, meaning the value types associated with these components are restricted to basic primitive datatypes (real numbers, discrete values, or boolean values). This specification clarifies that target primitive field components are intended for use where target variables are representable by primitive datatypes."}
{"class": "target boolean field component", "description": "target boolean field component is defined as a subclass of labeled dataset target field component. It is further characterized by the restriction that it must play the role of some boolean datatype, meaning instances of this class are components within a labeled dataset that represent target fields specifically associated with boolean data types. This ensures that the target values handled by this component are strictly boolean (i.e., true or false)."}
{"class": "target discrete field component", "description": "target discrete field component is defined as a subclass of labeled dataset target field component. It is characterized by having a role that is associated with some discrete datatype, meaning the data values it represents are distinct and separate (e.g., categories or integers) rather than continuous. This ensures that every target discrete field component specifically involves target fields where the underlying data type is discrete."}
{"class": "target real field component", "description": "target real field component is a subclass of labeled dataset target field component. Individuals of this class are characterized by the restriction that they must play the role of some real datatype. This means that any target real field component represents a field component used as a target in labeled datasets, specifically associated with or representing real-valued data."}
{"class": "target sequence of real field component", "description": "target sequence of real field component is a subclass of labeled dataset target field component. Members of this class are characterized by having the role_of some sequence of real datatype, meaning that each instance serves as a target field in a labeled dataset and fills a role associated with a sequence of real numbers (e.g., real-valued vectors or time series). This formalization restricts class membership to those dataset components whose target data are structured as sequences of real numbers."}
{"class": "target hierarchical field component", "description": "target hierarchical field component is defined as a subclass of labeled dataset target field component. Members of this class are further characterized by the axiom that they fulfill the role_of relationship with some instance of either a tree datatype or a directed acyclic graph (DAG) datatype. This indicates that such components specifically serve as target fields in labeled datasets, where the targets are drawn from hierarchical data structures represented as either trees or DAGs."}
{"class": "target DAG field component", "description": "target DAG field component is defined as a subclass of labeled dataset target field component and is further characterized by the property restriction that it must serve in the role_of some DAG datatype. This means that any instance of target DAG field component is specifically related to Directed Acyclic Graph (DAG) datatypes, describing target fields in labeled datasets that are intended to represent or interact with DAG structures."}
{"class": "target tree field component", "description": "target tree field component is defined as a subclass of labeled dataset target field component. Members of this class are characterized by the restriction that they must play the role of some tree datatype. This formalization specifies that any target tree field component is associated with a structure fundamentally based on tree datatypes, differentiating it from other target field components by its reliance on hierarchical or tree-structured data."}
{"class": "target set of discrete field component", "description": "target set of discrete field component is defined as a subclass of labeled dataset target field component. Every individual in this class must play the role of some set of discrete datatype, meaning each component serves as a target field in a labeled dataset whose values are constrained to a discrete set. This ensures that the target values for this component are not continuous but instead belong to a well-defined set, aligning with tasks such as multi-class classification in machine learning."}
{"class": "target record of primitives field component", "description": "target record of primitives field component is defined as a subclass of labeled dataset target field component. Every instance of this class has the property that it plays the role_of at least one record of primitives datatype. This formalization ensures that any target record of primitives field component is associated, through the role_of relationship, with data characterized as a record of primitives datatype, linking target fields within labeled datasets to primitive data representations."}
{"class": "target record of boolean field component", "description": "target record of boolean field component is defined as a subclass of labeled dataset target field component. Members of this class are characterized by the property that they play the role_of some record of boolean datatype, indicating that these components specifically serve as targets in datasets where the associated data is restricted to boolean (true/false) values. This formalization ensures that any instance of this class must be linked to records containing only boolean-typed data, supporting clear distinction in data modeling for boolean-labeled target fields."}
{"class": "target record of discrete field component", "description": "target record of discrete field component is a subclass of labeled dataset target field component, and is characterized by a property restriction indicating it must play the role of some record of discrete datatype. This means that any instance of this class represents a target field component within a labeled dataset, specifically one that is associated with a record whose datatype is discrete."}
{"class": "target record of reals field component", "description": "target record of reals field component is defined as a subclass of labeled dataset target field component. Each member of this class must fulfill the property restriction of being the role_of some record of real datatype, ensuring that instances of this class represent components associated with labeled dataset targets, specifically those that play a role in or are linked to data records typed as real values (real numbers)."}
{"class": "target structured field component", "description": "target structured field component is a subclass of labeled dataset target field component. Members of this class are further characterized by the requirement that they play some role in relation to a structured data type; specifically, they must be associated with one or more of the following datatypes: table, array, class, sequence, bag, or set. This definition ensures that any target structured field component is a labeled field designated for structured or collection-type datatypes within the context of a dataset."}
{"class": "descriptive record of primitives field component", "description": "descriptive record of primitives field component is a subclass of labeled dataset descriptive field component. Every instance of this class must be associated, via the property role_of, with at least one record of primitives datatype. This formalization indicates that members play a specific role in describing labeled datasets by being directly linked to data representations consisting of primitive types."}
{"class": "descriptive record of reals field component", "description": "descriptive record of reals field component is defined as a subclass of labeled dataset descriptive field component. Members of this class are characterized by having the property role_of, which must relate them to some record of real datatype. This formalization ensures that any individual of this class functions specifically to describe or annotate dataset fields that are based on real-number values."}
{"class": "descriptive record of boolean field component", "description": "A descriptive record of boolean field component is defined as a subclass of labeled dataset descriptive field component. Any instance of this class must play the role of some record associated with a boolean datatype, signifying that its descriptive information pertains specifically to data fields that store boolean values."}
{"class": "descriptive record of discrete field component", "description": "descriptive record of discrete field component is a subclass of labeled dataset descriptive field component. It is characterized by the property that it plays some role in relation to a record of discrete datatype, indicating its involvement in describing or annotating fields within a labeled dataset that take on discrete values. This class ensures that its instances are specifically linked to descriptive information about discrete data fields."}
{"class": "descriptive set of integer field component", "description": "descriptive set of integer field component is a subclass of labeled dataset descriptive field component. Members of this class are characterized by having a role that involves some association with a set of integer datatype. This formalization ensures that any individual belonging to this class serves as a descriptive field within a labeled dataset, specifically representing or relating to a set of integer values."}
{"class": "descriptive strucured field component", "description": "descriptive structured field component is defined as a subclass of labeled dataset descriptive field component. It is characterized by having a role that must be associated with at least one of the following datatypes: array datatype, class datatype, sequence datatype, bag datatype, or set datatype. This ensures that instances of descriptive structured field component function specifically in contexts involving structured data representations such as arrays, classes, sequences, bags, or sets."}
{"class": "positive integer", "description": "positive integer is defined as a subclass of extended datatype, indicating that it is a specialized numerical datatype representing integers greater than zero within the broader category of extended datatypes. No additional constraints or properties are specified beyond this hierarchical relationship."}
{"class": "positive integer range generator", "description": "positive integer range generator is defined as a subclass of range subtype generator. This class represents generators specifically designed to produce ranges consisting only of positive integers, inheriting all characteristics of range subtype generator while specializing in handling positive integer values."}
{"class": "is_operation_of", "description": "The property \"is_operation_of\" has no explicitly defined domain or range restrictions and does not possess any special logical characteristics. It is defined as a sub-property of \"attribute_of,\" indicating that it represents a specific kind of attributions between entities. Additionally, it has an inverse property \"has_operation,\" establishing a bidirectional relationship between related entities."}
{"class": "identifier_for", "description": "The property \"identifier_for\" does not specify explicit domain or range restrictions and has no defined characteristics. It is a sub-property of \"attribute_of\" and serves as the inverse of the property \"has_identifier.\" This property is used to relate an identifier to the entity it identifies, reflecting an attribute relationship between the identifier and the entity."}
{"class": "has_attribute", "description": "The property \"has_attribute\" has no explicitly defined characteristics, domain, or range restrictions. It is a sub-property of owl:topObjectProperty and is defined as being its own inverse property, indicating a symmetric relationship. No additional description is currently provided."}
{"class": "has_identifier", "description": "The property \"has_identifier\" is defined as a sub-property of \"has_attribute\" and does not have explicitly stated characteristics, domain, or range restrictions. It represents an attribute relationship, likely used to associate an entity with a unique identifier, though no inverse property is specified."}
{"class": "attribute_of", "description": "The property \"attribute_of\" has no explicitly defined characteristics, domain, or range restrictions. It is not specified as a sub-property of any other property and does not have an inverse property. This property can be used generally to relate an attribute to any entity without further ontological constraints."}
{"class": "denotes", "description": "The property \"denotes\" has no explicitly defined domain, range, or characteristics. It is a sub-property of \"is-about\", indicating a more specific form of reference or relationship to a subject. No inverse property is specified. This property is typically used to express that one entity represents or refers to another in a symbolic or informational context."}
{"class": "is_member_of", "description": "The property \"is_member_of\" does not have specified domain or range restrictions and has no special characteristics defined. It is a sub-property of \"attribute_of\" and has \"has_member\" as its inverse property. This property is used to relate an entity to a group or collection to which it belongs."}
{"class": "has-value", "description": "The property \"has-value\" does not have explicitly defined characteristics, domain, range, super-properties, or inverse properties. This indicates a general-purpose property whose usage and constraints are not restricted by axioms in the current ontology specification."}
{"class": "role_of", "description": "The property \"role_of\" does not have explicitly specified domain or range restrictions and lacks defining characteristics. It is a sub-property of \"owl:topObjectProperty\" and has \"has_role\" as its inverse property. This property is typically used to relate a role to an entity, indicating that the entity plays or fulfills a particular role."}
{"class": "is-about", "description": "The property \"is-about\" does not have explicitly defined characteristics, domain, or range constraints. It is specified as a sub-property of the top-level object property (owl:topObjectProperty), indicating broad applicability for relating entities without restriction. No inverse property is defined. This property can be used to associate any two individuals to indicate that one is about the other."}
{"class": "owl:topObjectProperty", "description": "The property \"owl:topObjectProperty\" has no specified domain, range, characteristics, super-properties, or inverse property. It is the most general object property in OWL ontologies, capable of relating any pair of individuals without restriction."}
{"class": "has_role", "description": "The property \"has_role\" has no explicitly defined domain, range, or characteristics. It is a direct subproperty of owl:topObjectProperty, indicating broad applicability between individuals. No inverse property is specified. This property can be used to associate entities with their assigned roles without additional restrictions."}
{"class": "has_member", "description": "The property \"has_member\" has no explicit domain or range restrictions and is not defined with characteristics such as functional or transitive. It is declared as a sub-property of \"has_attribute,\" indicating that it inherits the general semantics of attributive relations. No inverse property is specified. This property is used to relate a group or collection to its members in a manner consistent with general attribute relations."}
{"class": "has_quality", "description": "The property \"has_quality\" has no explicitly defined domain, range, characteristics, or inverse properties. It is declared as a subproperty of \"owl:topObjectProperty,\" indicating it is a general object property that can relate any two individuals. This property is typically used to associate an entity with a quality or characteristic, but no additional restrictions are imposed by its current axioms."}
{"class": "represents", "description": "The property \"represents\" has no explicitly defined domain, range, or characteristics, and does not specify an inverse property. It is a sub-property of owl:topObjectProperty, indicating it is a very general object property that can relate any two individuals in the ontology. No further semantic constraints are provided."}
{"class": "is_quality_of", "description": "The property \"is_quality_of\" has no explicitly defined characteristics, domain, or range restrictions, and is not specified as a sub-property of any other property. It is defined as the inverse of the property \"has_quality,\" indicating that it relates a quality to the entity it qualifies."}
{"class": "has_operation", "description": "The property \"has_operation\" does not have explicitly defined characteristics, domain, or range restrictions. It is declared as a sub-property of \"has_attribute,\" indicating that it inherits the general meaning of associating an attribute with an entity, with a more specific focus on operations. No inverse property is specified."}
