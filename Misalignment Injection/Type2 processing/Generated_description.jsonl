{"class": "ObjectEvent", "description": "ObjectEvent is a subclass of Event, characterized by the restriction that it must have exactly one Object as its agent. This means every instance of ObjectEvent is an Event in which precisely one Object acts as the agent. This axiom ensures clear and unambiguous assignment of agency within such events."}
{"class": "AmbientMeasurement", "description": "AmbientMeasurement is a class whose instances are characterized by the property that they only refer to Room; that is, any AmbientMeasurement must be associated exclusively with one or more Rooms. This restriction ensures that AmbientMeasurement data cannot pertain to entities outside the Room class."}
{"class": "DoorClosed", "description": "DoorClosed is defined as a subclass of Closed, meaning every DoorClosed instance is also a Closed instance. There are no additional property restrictions specified for this class. This formalization indicates that DoorClosed represents the specific state where a door is closed, inheriting all characteristics of the broader Closed class."}
{"class": "SkinConductivity", "description": "SkinConductivity is defined as a subclass of PhysiologicalMeasurement, representing measurements related to skin's electrical properties. Every instance of SkinConductivity is constrained such that its hasConductivity property can only take values of type rdfs:Literal, ensuring that conductivity data is recorded in a literal data format (e.g., numeric or text values)."}
{"class": "NearObject", "description": "NearObject is defined as a subclass of InLocation, meaning every NearObject is also considered to be located in a specific place or context. There are no additional property restrictions specified for this class."}
{"class": "LightLevel", "description": "LightLevel is defined as a subclass of AmbientMeasurement. Every instance of LightLevel must be associated with exactly one value via the property hasLightLevel, indicating that each measurement in this class represents a single, specific light level reading. This formalization ensures consistency in quantifying ambient light for each measurement instance."}
{"class": "Sitting", "description": "Sitting is defined as a subclass of Posture. This means that every instance of Sitting is also an instance of Posture, representing a specific type of body position or stance, but no additional property restrictions are specified for this class."}
{"class": "hasRate", "description": "The property \"hasRate\" has no explicitly specified domain, range, characteristics, super-properties, or inverse properties. This indicates that it is a general-purpose property, with its usage and applicable types left unspecified by the current axioms."}
{"class": "hasAgent", "description": "The property \"hasAgent\" is an object property without explicitly defined characteristics, domain, or range restrictions. It is specified as a subproperty of \"owl:topObjectProperty,\" indicating it inherits the broadest possible usage among object properties. No inverse property is defined."}
{"class": "hasNoiseLevel", "description": "The property \"hasNoiseLevel\" has no explicitly defined characteristics, domain, or range restrictions. It does not declare any super-properties or inverse properties. This indicates that the property can be used flexibly to relate entities to unspecified values representing noise levels, without ontological constraints on the types of subjects or objects."}
{"class": "isAgentIn", "description": "The property \"isAgentIn\" has no explicitly defined characteristics, domain, or range restrictions, and it does not declare any super-properties or inverse properties. Its intended use should be clarified with additional axioms or documentation."}
{"class": "PhysicalObject", "description": "PhysicalObject is defined as a subclass of PhysicalEndurant. This means every PhysicalObject necessarily inherits all characteristics of PhysicalEndurants. There are no explicit disjointness constraints specified, so PhysicalObject may overlap with other subclasses of PhysicalEndurant unless otherwise restricted in the ontology."}
{"class": "Molecule", "description": "Molecule is defined as a subclass of PhysicalObject, indicating that every molecule is a type of physical entity. There are no additional property restrictions specified for this class."}
{"class": "MixedStuff", "description": "MixedStuff is defined as a subclass of Stuff, specifically representing entities that consist of at least two component parts, each of which is itself a Stuff. This formalization requires any instance of MixedStuff to have at least two distinct Stuff components through the hasPartStuff property. MixedStuff is not specified to be disjoint with any other class."}
{"class": "Colloid", "description": "Colloid is formally defined as a type of homogeneous mixture characterized by having exactly two distinct components: one continuous medium and one dispersed phase, each represented as a unique part (stuff) that exists in at least some physical state. The structure requires at least two phases in total, with the dispersed phase and continuous medium inhering in their respective stuffs. This precise definition captures the essential nature of colloids as multi-phase, homogeneous systems."}
{"class": "ContinuousMedium", "description": "ContinuousMedium is defined as a subclass of StuffRole. Members of this class are characterized by the existence of at least one colloidFormingRelation to an individual of the DispersedPhase class. This means any instance of ContinuousMedium must participate in a relationship where it serves as the medium in which a dispersed phase is present, reflecting its role in colloidal systems. There are no explicit disjointness constraints for this class."}
{"class": "Distribution", "description": "Distribution is a class whose members are characterized by the requirement that they must have at least one quale that is either an EvenDistribution or an UnevenDistribution. This means any individual of the Distribution class must be associated, through the hasQuale property, with a quale reflecting either evenness or unevenness in distribution."}
{"class": "Foam", "description": "Foam is defined as a subclass of DispersionColloid, indicating that every instance of foam is a type of dispersion colloid. This means that foams inherit all properties and restrictions of DispersionColloid, but no additional equivalence conditions or distinguishing characteristics are specified beyond this subclass relationship."}
{"class": "LiquidAerosol", "description": "LiquidAerosol is defined as a type of DispersionColloid that consists of exactly one component of gas in the continuous medium and exactly one component of liquid in the dispersed phase. Formally, any member of this class must have a gas substance (Stuff) that inheres in the continuous medium, and a liquid substance (Stuff) that inheres in the dispersed phase. This definition captures systems where liquid droplets are dispersed throughout a gaseous medium, such as mist or fog."}
{"class": "SolidAerosol", "description": "SolidAerosol is defined as a specific type of DispersionColloid characterized by having exactly one component (part) of Stuff in a gaseous state that inheres in a ContinuousMedium, and exactly one component (part) of Stuff in a solid state that inheres in a DispersedPhase. This formalization precisely captures a system where solid particles are dispersed within a gaseous medium."}
{"class": "SolidSol", "description": "SolidSol is a class defined as an equivalent class to a dispersion colloid that consists of exactly two types of solid components: one that inheres in a continuous medium and another that inheres in a dispersed phase. Both parts must be in a solid state, and each occurs exactly once within the SolidSol. This formalization captures the structure of a solid sol, where solid particles are dispersed within a solid continuous medium, both being distinct and occurring exactly once, consistent with the classical understanding of solid sols in colloidal science."}
{"class": "HomogeneousMixture", "description": "HomogeneousMixture is defined as a subclass of MixedStuff, where every instance is required to have exactly one hasStuffDistribution property value, and that value must be an EvenDistribution. This formalization captures the concept that all parts of a homogeneous mixture are distributed uniformly, distinguishing it from other types of mixtures."}
{"class": "PhysicalEndurant", "description": "PhysicalEndurant is defined as a subclass of Endurant and is equivalent to om-1:Phenomenon, indicating that every instance of PhysicalEndurant corresponds to an instance of om-1:Phenomenon and vice versa. There are no specified disjointness constraints. This class represents entities that persist through time while maintaining their identity and physical characteristics."}
{"class": "StructuredPureStuff", "description": "StructuredPureStuff is a subclass of PureStuff and is equivalent to those PureStuff individuals that have exactly one granule type, which must be a Molecule. This means every instance of StructuredPureStuff is composed exclusively of a single type of molecule and cannot have multiple or different granule types. There are no explicit disjointness constraints specified with any other classes."}
{"class": "Suspension", "description": "Suspension is defined as a type of heterogeneous mixture in which the mixture contains both liquid and solid phases: it necessarily has components (hasPartStuff) where one part is a substance in a liquid state that inheres in (i.e., serves as) a continuous medium, and another part is a substance in a solid state that inheres in a dispersed phase. Additionally, any suspension must involve granule types that include both Molecule and MultiMoleculeParticle. This class formalization ensures that suspensions are mixtures where solid particles (typically larger than molecules) are dispersed within a liquid medium, reflecting the classical definition in physical sciences."}
{"class": "scatterPortion", "description": "The property \"scatterPortion\" has no explicitly defined characteristics, domain, or range restrictions. It is declared as a sub-property of \"hasProperPart,\" indicating that it inherits the semantic of relating entities to their distinct non-overlapping parts. No inverse property is specified."}
{"class": "inheresIn", "description": "The property \"inheresIn\" has no specified characteristics, domain restrictions, super-properties, or inverse properties. Its range is restricted to instances of \"PhysicalEndurant,\" meaning it is used to relate a subject to a physical endurant entity."}
{"class": "properContainedIn", "description": "The property \"properContainedIn\" has no explicitly defined characteristics, domain, or range restrictions. It does not inherit from any super-properties and does not specify any inverse property. This suggests the property is intended to represent a containment relation, but its usage is not further constrained by the axioms."}
{"class": "hasNrOfPhase", "description": "The property \"hasNrOfPhase\" has no explicitly defined characteristics, domain, super-properties, or inverse properties. Its range is restricted to integer values (xsd:integer), indicating its use for associating entities with a numerical value representing the number of phases."}
{"class": "srInheresIn", "description": "The property \"srInheresIn\" has no specified characteristics or super-properties. Its domain is restricted to instances of \"StuffRole\", and its range is limited to instances of \"Stuff\". This property is used to relate a \"StuffRole\" to the \"Stuff\" in which it inheres. No inverse property is defined."}
{"class": "solutionFormingRelation", "description": "The property \"solutionFormingRelation\" has no specified characteristics or super-properties. Its domain is restricted to entities classified as \"Solvent,\" and its range to entities classified as \"Solute.\" This property is used to relate solvents to the solutes they dissolve. No inverse property is specified."}
{"class": "colloidFormingRelation", "description": "The property \"colloidFormingRelation\" has no explicitly defined characteristics or super-properties. Its domain is restricted to instances of \"ContinuousMedium\", and its range is restricted to instances of \"DispersedPhase\". This property is used to relate a continuous medium to a dispersed phase in the context of colloid formation. No inverse property is specified."}
{"class": "instantiation", "description": "The property \"instantiation\" has a domain restricted to \"AmountOfStuff\" but no specified range, characteristics, super-properties, or inverse properties. This indicates that \"instantiation\" is intended to relate entities of type \"AmountOfStuff\" to unspecified targets."}
{"class": "hasDataValue", "description": "The property \"hasDataValue\" does not have any explicitly defined characteristics, domain, range, super-properties, or inverse properties. This suggests it is a general property without specified usage constraints or relationships in the ontology."}
{"class": "hasPart", "description": "The property \"hasPart\" has no explicitly defined characteristics, domain, range, super-properties, or inverse properties. This indicates it is a general-purpose property used to relate an entity to its constituent parts, without constraints on the types of entities it connects."}
{"class": "hasScatterStuffPart", "description": "The property \"hasScatterStuffPart\" has no explicitly defined characteristics, domain, or range restrictions. It is specified as a sub-property of \"hasProperPart,\" indicating that any instance of \"hasScatterStuffPart\" also qualifies as an instance of \"hasProperPart.\" No inverse property is defined."}
{"class": "hasQuale", "description": "The property \"hasQuale\" does not specify domain restrictions, characteristics, super-properties, or an inverse property. Its range is restricted to individuals classified as \"Abstract,\" indicating it is used to relate entities to abstract qualities or properties."}
{"class": "procedure-paremeter declaration", "description": "procedure-parameter declaration is a class characterized by the requirement that its instances must have at least one member that is a parameter and at least one member that is a direction. No superclass is specified, and there are no disjointness axioms defined. This formalization ensures that any individual classified as a procedure-parameter declaration is necessarily associated with both a parameter and a direction through the has_member property."}
{"class": "datatype role", "description": "datatype role is defined as a subclass of role, inheriting all characteristics of the broader role class. There are no additional property restrictions specified for datatype role, so its classification is determined solely by its status as a type of role."}
{"class": "range subtype generator", "description": "range subtype generator is a class whose members are defined by the existence of at least one relationship via the property has_member to an individual of the class range. This means that any instance of range subtype generator must be associated with at least one range individual. There are no subclass or disjointness axioms specified for this class."}
{"class": "non-directed labeled graph datatype", "description": "non-directed labeled graph datatype is defined as a subclass of defined datatype. Any instance of this class must have at least one member that is a graph aggregate component, indicating that its values are aggregates composed of graph elements. This definition formalizes the requirement that all non-directed labeled graph datatypes consist of aggregate components relevant to graph structures."}
{"class": "homogenous aggregate generator with variable size", "description": "A homogenous aggregate generator with variable size is defined as any entity that has the quality of variable size. It is not specified as a subclass of another class, but every instance must possess some quality indicating its size can change or vary."}
{"class": "class generator", "description": "class generator is defined as a subclass of heterogenous aggregate generator and is explicitly disjoint with record generator, ensuring that no individual can simultaneously belong to both classes. Members of this class are characterized by having the following qualities: key access, unordered aggregate structure, allowance of non-unique values, one-dimensionality, and a fixed size. These property restrictions formalize the structural and access properties of the class generator, distinguishing it clearly within the ontology."}
{"class": "sequence generator", "description": "sequence generator is defined as a subclass of homogenous aggregate generator with variable size. Members of this class are characterized by possessing the qualities of: containing non-unique values (allowing repeated elements), forming an ordered aggregate (where the arrangement of elements matters), and supporting access by position (enabling retrieval of elements based on their position in the sequence). There are currently no explicit disjointness restrictions specified for this class."}
{"class": "pointer generator", "description": "pointer generator is a class defined by the restriction that its members must be associated with at least one pointer datatype via the property is_member_of. This means that any individual of the pointer generator class must be linked to some instance of pointer datatype, ensuring participation in at least one pointer datatype group. There are no specified superclasses for pointer generator."}
{"class": "record (tuple) datatype", "description": "record (tuple) datatype is defined as a subclass of heterogenous aggregate datatype. Instances of this class must possess at least one non-numeric quality, exhibit exactness, and are explicitly non-ordered. Each record (tuple) is composed of members that include at least one record generator and a field-list, reflecting its structure as an aggregation of potentially diverse fields. Additionally, records (tuples) are characterized by operations such as equality comparison (Equal:record) and field replacement (FieldReplace:record), which are applicable specifically to this datatype. These restrictions ensure that records (tuples) function as non-ordered, heterogenous aggregates with field-based structure and well-defined operational behaviors."}
{"class": "aggregate imposed ordering", "description": "aggregate imposed ordering is defined as a subclass of aggregate generator property, and is equivalent to either an ordered aggregate or an unordered aggregate. The class is explicitly disjoint with aggregate-imposed identifier uniqueness, homogenity, agregate size, component mandatoriness, structurness, recursiveness, and access type, guaranteeing that no individual can simultaneously belong to any of these classes. This formalization ensures that aggregate imposed ordering represents a specific generator property related to the ordering characteristic of aggregates, distinct from other aggregate-related properties."}
{"class": "agregate size", "description": "aggregate size is defined as a subclass of aggregate generator property and is formally disjoint with the classes uniqueness, component mandatoriness, structurness, and recursiveness—ensuring no individual can belong to aggregate size and any of those classes simultaneously. Furthermore, aggregate size is equivalent to the union of fixed size and variable size, meaning every aggregate size is either a fixed size or a variable size. This class characterizes properties describing whether the size of an aggregate is constant or may vary, distinguishing it from other structural aggregate properties."}
{"class": "structurness", "description": "structurness is defined as a subclass of aggregate generator property and is mutually exclusive (disjoint) with recursiveness, meaning no instance can simultaneously possess both properties. Structurness is equivalent to the union of structured, unstructured, or semi-structured classes; thus, any entity classified under structurness must be classified as one of these three types and vice versa. This ensures a comprehensive coverage of data organizational forms within the scope of aggregate generator properties, while clearly differentiating from recursive properties."}
{"class": "dimensionality", "description": "dimensionality is defined as a subclass of aggregate generator property, indicating that it represents a specific type of property associated with aggregate generators. This classification establishes that dimensionality inherits all characteristics and constraints of aggregate generator properties, but no additional equivalence to other classes is explicitly specified."}
{"class": "defined datatype", "description": "defined datatype is a class characterized by the requirement that its members must have at least one has_member relationship to an individual of the class defined generator, and at least one has_member relationship to an individual of the class defined datatype parameter-list. There are no further subclass or property restrictions specified, indicating that the core definition relies on these membership conditions."}
{"class": "tag-type", "description": "tag-type is defined as a subclass of datatype role. This means every instance of tag-type is also an instance of datatype role, inheriting its characteristics, but no additional property restrictions or differentiating axioms are specified for tag-type."}
{"class": "pointer-element-type", "description": "pointer-element-type is a class defined by the restriction that its members must play the role of at least one datatype (i.e., each pointer-element-type is characterized as being in the role_of some datatype). No further subclass or disjointness relationships are specified."}
{"class": "base type", "description": "base type is defined as a subclass of datatype role, characterized by the property that any base type must be a member of at least one of the following datatypes: array datatype, sequence datatype, bag datatype, set datatype, or extended datatype. This ensures all individuals classified as base type participate in at least one of these specified datatype structures."}
{"class": "boolean field-list", "description": "boolean field-list is defined as a subclass of field-list, where every instance must have at least one member that is a boolean field component. There are no specified disjointness constraints with other classes. This formalizes that a boolean field-list is distinguished by the presence of boolean field components among its members."}
{"class": "labeled dataset field-list", "description": "labeled dataset field-list is defined as a subclass of field-list, with the additional constraint that every instance must have at least one member that is a labeled dataset target field component. This ensures that any labeled dataset field-list necessarily contains components specifically designated as labeled dataset target field components among its members."}
{"class": "niladic operation", "description": "niladic operation is defined as a subclass of characterizing operation, meaning it inherits all properties of characterizing operations. It is also explicitly disjoint with n-adic operation, ensuring that no individual can be both a niladic operation and an n-adic operation. This formalization characterizes niladic operation as a distinct type of characterizing operation that is fundamentally separate from operations involving any number of arguments."}
{"class": "discrete-value-list", "description": "discrete-value-list is defined as a subclass of list specification. This means it represents a specific type of list specification, inheriting all characteristics of list specification, but does not introduce any additional property restrictions or disjointness conditions."}
{"class": "defined datatype parameter-list", "description": "defined datatype parameter-list is a subclass of list specification. This means that every defined datatype parameter-list is considered a specific kind of list specification, inheriting all general characteristics of list specifications without introducing any additional property restrictions."}
{"class": "index-type list", "description": "index-type list is defined as a subclass of list specification, indicating that every index-type list is a specialized form of list specification. There are no additional property restrictions or disjointness axioms specified for this class."}
{"class": "tree datatype generator", "description": "tree datatype generator is defined as a subclass of directed labeled graph datatype generator. This indicates that every tree datatype generator is a specialized form of directed labeled graph datatype generator, inheriting its characteristics and constraints. No explicit disjointness with other classes is asserted."}
{"class": "scaled datatype", "description": "scaled datatype is defined as a subclass of numeric ordered primitive datatype, and is explicitly disjoint with integer datatype, meaning an individual cannot simultaneously be an instance of both. Members of scaled datatype are characterized by the presence of certain qualities and members, including some unbounded and exact qualities, as well as the inclusion of scaled radix and scaled factor as members. The class is further defined by its ability to support specific operations: Divide:scaled, Multiply:scaled, Add:scaled, Equal:scaled, Negate:scaled, Round:scaled, and InOrder:scaled. These axioms ensure that any instance of scaled datatype possesses precise numeric capabilities, distinct from integer datatypes, and is designed to support a variety of scaling and arithmetic operations."}
{"class": "rational datatype", "description": "rational datatype is a subclass of numeric ordered primitive datatype. It possesses numerical, ordered, and exact qualities, indicating its values are precise, can be compared according to an order, and are of a numerical nature. Members of this class support a range of operations restricted to rational types, including addition, multiplication, negation, reciprocation, promoting to a different form, testing equality, ensuring non-negativity, and ordering. These axioms collectively formalize rational datatypes as exact, ordered primitive types over which rational-specific numeric operations are defined."}
{"class": "exactness", "description": "exactness is defined as a subclass of datatype property, and is designated as disjoint from numericalness, cardinality, boundedness, and equality, ensuring that no individual can belong to both exactness and any of these classes simultaneously. exactness is equivalent to the union of approximate and exact, meaning that any instance of exactness must also be either an instance of approximate or of exact. This models properties that describe whether or not a value or measure is exact or approximate, without overlapping with numericalness, cardinality, boundedness, or equality."}
{"class": "order", "description": "order is a subclass of datatype property, representing properties whose values impose an ordering. It is explicitly disjoint with boundedness, ensuring that no individual can be both an order and a boundedness property. The class is further defined as equivalent to the union of ordered or non-ordered properties, meaning any instance of order must be either ordered or non-ordered, but not both. This characterization distinguishes order as a fundamental property related to the arrangement of data values, distinct from properties concerned with data bounds."}
{"class": "discrete field component", "description": "discrete field component is defined as a subclass of primitive field component and is explicitly disjoint with boolean field component—no individual can belong to both classes. Every discrete field component must be associated, via the role_of property, with at least one discrete datatype. This ensures that discrete field components specifically relate to discrete datatypes and are distinguished from boolean field components within the ontology."}
{"class": "pointer datatype", "description": "pointer datatype is a class characterized by several defining properties: it must have at least one member that is a pointer generator and at least one member that is a pointer-element-type. Instances are required to possess the qualities of being non-ordered, non-numeric, and exact. Additionally, pointer datatypes must support the operations \"Equal:pointer\" and \"Dereference:pointer\". No further subclass constraints are specified."}
{"class": "tree datatype", "description": "tree datatype is defined as a subclass of labeled graph datatype. Every tree datatype is required to have at least one member that is an instance of tree datatype generator, as indicated by the property restriction (has_member some tree datatype generator). There are no explicit disjointness constraints specified for this class. This formalization captures the requirement that tree datatypes are structured within the hierarchy of labeled graph datatypes and are generated or constructed via specific tree datatype generators."}
{"class": "lower bound", "description": "lower bound is a class whose instances are required to have exactly one value for the property has-value, and this value must be of type xsd:integer. This ensures each member of lower bound is associated with precisely one integer value."}
{"class": "index lowerbound", "description": "index lowerbound is defined as a subclass of bound. This means that every index lowerbound is a type of bound, inheriting all characteristics and constraints associated with the bound class. There are no additional property restrictions specified for this class."}
{"class": "defined generator", "description": "defined generator is a subclass of datatype generator. This means every defined generator is necessarily a datatype generator, inheriting all its characteristics, but may also have additional distinguishing properties or constraints not specified here."}
{"class": "real base type", "description": "real base type is a class whose members are defined by their participation in the role_of property with at least one instance of the real datatype. This means every individual of real base type must be in a role_of relation with some real datatype, but there are no additional subclass relationships or property restrictions specified."}
{"class": "record of real datatype", "description": "record of real datatype is defined as a subclass of record (tuple) datatype. Any instance of this class must have at least one member that is a real field-list, as specified by the property restriction [has_member some real field-list]. This class represents composite data structures in which at least one component is drawn from the set of real-number-based data fields."}
{"class": "labeled dataset record datatype", "description": "labeled dataset record datatype is defined as a subclass of record (tuple) datatype. This means every instance of labeled dataset record datatype is also a record (tuple) datatype, inheriting all characteristics of records, but with additional meaning or usage specific to labeled datasets. No further property restrictions or axioms are specified for this class."}
{"class": "set of real datatype", "description": "set of real datatype is a class whose members are collections containing at least one element from the real base type. The only formal restriction is that each instance must have at least one member that is a real base type, ensuring that all such sets are connected to real-numbered data elements."}
{"class": "non-aggregate datatype", "description": "non-aggregate datatype is a class whose individuals are required to have at least one member related via the property has_member to an individual of the class non-aggregate generator. There are no specified superclasses. This restriction ensures that every non-aggregate datatype includes at least one non-aggregate generator as a member."}
{"class": "ordinal datatype", "description": "ordinal datatype is defined as a subclass of non-numeric ordered primitive datatype. It is characterized by possessing qualities such as being bounded below, potentially unbounded above, ordered, non-numeric, and exact. Members of this class support specific operations, including having an in-order operation and a successor operation, both tailored for ordinal values. This formalization ensures that ordinal datatypes represent strictly ordered, non-numeric values with well-defined successor functions and clear lower bounds, though they may lack an upper bound."}
{"class": "datatype", "description": "datatype is a class characterized by the presence of certain properties: each member must have at least one datatype property (expressed via has_quality), must be associated with at least one characterizing operation (via has_operation), and must have at least one value space attribute (via has_attribute). This formalization ensures that any instance of datatype is inherently linked to specific qualities, operations, and value spaces that define its structure and semantics."}
{"class": "numeric ordered primitive datatype", "description": "numeric ordered primitive datatype is defined as a subclass of numeric primitive datatype. This means that every instance of numeric ordered primitive datatype is also an instance of numeric primitive datatype, inheriting all the characteristics of the parent class. There are no additional property restrictions or axioms further constraining this class."}
{"class": "sequence datatype", "description": "sequence datatype is a subclass of homogenous aggregate datatype with variable size. It is characterized by having members of a base type and potentially a sequence generator. Sequence datatypes are non-ordered, non-numeric collections, and their elements all share the same type. They support operations such as equality checking (Equal:sequence), checking if the sequence is empty (IsEmpty:sequence), obtaining the first element (Head:sequence) or the remainder after the first element (Tail:sequence), and appending new elements (Append:sequence). All members of this class have the qualities of being non-ordered and exact."}
{"class": "set datatype", "description": "set datatype is a subclass of homogeneous unordered aggregate datatypes with variable size. Members of this class have the qualities of being non-ordered, non-numeric, and exact. A set datatype consists of members that are either of a base type or are generated by a set generator. The class supports fundamental set operations, including union, intersection, difference, subset, equality checking, creating an empty set, and creating a set of sets. These axioms formalize the characteristics and operations that define mathematical sets within a datatype context."}
{"class": "primitive field component", "description": "primitive field component is defined as a subclass of field component. This means every primitive field component is also a field component, but no further distinguishing characteristics or property restrictions are specified for this class."}
{"class": "numeric primitive datatype", "description": "numeric primitive datatype is a class whose members are entities that possess at least one quality characterized as numeric, as indicated by the property restriction [has_quality some numeric]. There are no asserted superclasses, indicating this class is not explicitly defined as a subclass of any other class in the ontology."}
{"class": "non-numeric unordered primitive datatype", "description": "non-numeric unordered primitive datatype is defined as a subclass of non-numeric primitive datatype, characterized by the property that its members possess at least one quality of being non-ordered (has_quality some non-ordered). No additional disjointness constraints are declared. This means all individuals in this class are primitive datatypes that are non-numeric and inherently lack an ordering among their values."}
{"class": "heterogenous aggregate datatype", "description": "heterogenous aggregate datatype is defined as a class whose members must each have at least one member (via the has_member property) that is an instance of the class heterogenous aggregate generator. This means every instance of heterogenous aggregate datatype is characterized by its association with at least one heterogenous aggregate generator, though no additional axiomatic constraints or superclass relationships are specified for this class."}
{"class": "bounded above", "description": "bounded above is defined as a subclass of bounded, indicating that every instance of bounded above is also an instance of bounded. There are no explicit disjointness restrictions specified for this class. This means any member of bounded above inherits all properties and constraints of bounded, and may have additional distinguishing characteristics not specified here."}
{"class": "bounded", "description": "bounded is defined as a subclass of boundedness, which means every instance of bounded is necessarily also an instance of boundedness. There are no specified disjointness or additional property restrictions for this class, so its primary characterization is its placement within the hierarchy under boundedness."}
{"class": "numeric", "description": "numeric is defined as a subclass of numericalness, indicating that every instance of numeric is also an instance of numericalness. There are no explicit disjointness axioms specified, so numeric may potentially overlap with other classes unless otherwise stated. This class formalizes the concept of entities possessing numeric or quantitative attributes, within the broader category of numericalness."}
{"class": "Delete:bag", "description": "Delete:bag is defined as a subclass of delete operation, indicating that it inherits all characteristics of delete operations. There are no specified disjointness restrictions for this class."}
{"class": "Select:array", "description": "Select:array is defined as a subclass of dyadic select operation. This means that every instance of Select:array is a specific type of dyadic select operation. No additional disjointness or property restrictions are specified for this class."}
{"class": "Select:bag", "description": "Select:bag is defined as a subclass of monadic select operation, indicating that every instance of Select:bag represents a specific type of single-argument selection process within the broader category of monadic select operations. There are no explicit disjointness constraints specified for this class."}
{"class": "Round:scaled", "description": "Round:scaled is defined as a subclass of round operation, indicating that it represents a specific type of rounding operation. There are no explicit disjointness constraints with other classes. All instances of Round:scaled are also considered instances of round operation."}
{"class": "Successor:enumerated", "description": "Successor:enumerated is defined as a subclass of successor operation, indicating that every instance of Successor:enumerated is also an instance of successor operation. There are no specified disjointness constraints for this class. This formalization is used to distinguish a specific kind or subset of successor operations, grouped as \"enumerated,\" within the broader successor operation category."}
{"class": "ordered aggregate", "description": "ordered aggregate is defined as a subclass of aggregate imposed ordering, indicating that it represents a type of aggregate in which an explicit ordering of elements is imposed. There are no disjointness axioms specified, so this class may potentially overlap with other classes unless otherwise stated."}
{"class": "fixed size", "description": "fixed size is defined as a subclass of agregate size, indicating that every instance of fixed size is also an instance of agregate size. There are no explicit disjointness constraints specified for this class."}
{"class": "homogenous", "description": "homogenous is a subclass of homogenity, meaning every instance of homogenous must also be an instance of homogenity. There are no explicit disjointness axioms specified, so individuals of this class are not formally excluded from membership in any other class."}
{"class": "non-unique values", "description": "non-unique values is defined as a subclass of uniqueness, indicating that it inherits all properties of uniqueness. However, the axiom does not specify any additional distinguishing features or restrictions, and non-unique values is not explicitly disjoint with any other class. This suggests it represents a special case or refinement of uniqueness, where the unique constraints may be relaxed or specifically defined elsewhere."}
{"class": "target record of reals field component", "description": "target record of reals field component is a class whose members are characterized by participating in the role_of property with at least one record of real datatype. This means that every instance of this class must function in some role specifically related to a record whose values are of a real datatype."}
{"class": "descriptive record of reals field component", "description": "descriptive record of reals field component is defined as a subclass of labeled dataset descriptive field component. This means that every instance of descriptive record of reals field component is also considered an instance of labeled dataset descriptive field component. There are no additional property restrictions or disjointness axioms specified for this class."}
{"class": "descriptive set of integer field component", "description": "descriptive set of integer field component is defined as a subclass of labeled dataset descriptive field component. This means every descriptive set of integer field component is inherently a labeled dataset descriptive field component, inheriting all its properties and constraints. No additional property restrictions or disjointness axioms are specified for this class."}
{"class": "is-about", "description": "The property \"is-about\" has no defined characteristics, domain, range, super-properties, or inverse properties. This indicates that it is a general-purpose property without explicit usage constraints or hierarchical relationships in the ontology."}
{"class": "is_quality_of", "description": "The property \"is_quality_of\" has no specified domain, range, characteristics, super-properties, or inverse properties. This indicates it can relate any two individuals without restrictions, and does not inherit constraints or semantics from other properties."}
{"class": "identifier_for", "description": "The property \"identifier_for\" has no explicitly defined domain or range restrictions and does not possess special characteristics. It is a sub-property of \"attribute_of\", indicating that it inherits the general meaning of being an attribute but specializes it for identifiers. No inverse property is specified."}
{"class": "has_quality", "description": "The property \"has_quality\" has no specified characteristics, domain, range, super-properties, or inverse properties. This generic property is intended to relate an entity to a quality, but its use is unconstrained by axioms."}
{"class": "has_attribute", "description": "The property \"has_attribute\" has no explicitly defined characteristics, domain, or range restrictions. It is a sub-property of \"owl:topObjectProperty,\" suggesting it is a general-purpose object property. No inverse property is specified."}
{"class": "denotes", "description": "The property \"denotes\" has no defined domain, range, characteristics, super-properties, or inverse properties. It is a generic property with no explicit ontological constraints."}
{"class": "time:Instant", "description": "time:Instant is defined as a subclass of time:TemporalEntity, meaning it represents a specific point within the temporal domain. There are no explicit disjointness axioms specified, so no additional exclusivity constraints are imposed."}
{"class": "time:Year", "description": "time:Year is a subclass of time:DurationDescription, formally defined as a duration consisting of exactly 1 year, with all other time units (months, days, hours, minutes, and seconds) restricted to exactly 0. This ensures that any individual of time:Year represents a duration of precisely one year, without any additional components."}
{"class": "time:DurationDescription", "description": "time:DurationDescription is a class representing temporal durations, where each instance is restricted to having at most one value for each of the following properties: time:hours, time:minutes, time:seconds, time:days, time:weeks, and time:years. This ensures that an individual duration description cannot specify more than one value for any temporal unit, maintaining a unique specification for each time component."}
{"class": "time:minutes", "description": "The property \"time:minutes\" has no explicitly defined characteristics, super-properties, or inverse properties. Its domain is restricted to instances of \"time:DurationDescription,\" indicating that it is intended to relate duration descriptions to a specific value or entity corresponding to minutes. The range of this property is not explicitly specified."}
{"class": "time:xsdDateTime", "description": "The property \"time:xsdDateTime\" has a domain restricted to \"time:DateTimeInterval\" and does not specify a range, characteristics, super-properties, or inverse properties. This property is used to associate instances of DateTimeInterval with additional information, likely a specific date and time value."}
{"class": "time:unitType", "description": "The property \"time:unitType\" has no specified characteristics, domain, super-properties, or inverse property. Its range is restricted to instances of \"time:TemporalUnit\", indicating that it associates a subject with a temporal unit."}
{"class": "time:month", "description": "The property \"time:month\" has no explicitly defined characteristics, domain restrictions, super-properties, or inverse properties.  \nIts range is restricted to values of data type xsd:gMonth, indicating it is used to relate an entity to a specific month in the Gregorian calendar."}
{"class": "time:hour", "description": "The property \"time:hour\" has \"time:DateTimeDescription\" as its domain, indicating it is used with instances of date and time descriptions. No explicit range, characteristics, super-properties, or inverse properties are defined. This property represents the hour component within a temporal description."}
{"class": "time:intervalOverlaps", "description": "The property \"time:intervalOverlaps\" has no explicitly defined characteristics, super-properties, or inverse properties. Its domain is restricted to instances of \"time:ProperInterval,\" indicating that it is used to relate proper time intervals to other entities. No specific range is defined for this property."}
{"class": "time:intervalFinishedBy", "description": "The property \"time:intervalFinishedBy\" has no explicitly defined characteristics, domain, range, super-properties, or inverse properties. This indicates that its usage is unrestricted by ontology axioms and is not semantically linked to other properties within the ontology."}
{"class": "time:intervalContains", "description": "The property \"time:intervalContains\" does not have explicitly defined characteristics, domain, range, super-properties, or inverse properties. Based on its name, it is likely intended to relate a temporal interval to another interval or event that it contains."}
{"class": "time:dayOfYear", "description": "The property \"time:dayOfYear\" has no specific characteristics, no explicit domain restrictions, and no defined super-properties. Its range is restricted to non-negative integers (xsd:nonNegativeInteger), indicating that it is used to represent the day of the year as a non-negative integer value. No inverse property is specified."}
{"class": "time:hasBeginning", "description": "The property \"time:hasBeginning\" does not have specified characteristics, domain restrictions, super-properties, or inverse properties. Its range is limited to individuals of type \"time:Instant,\" indicating it associates a subject with a temporal instant marking its beginning."}
{"class": "time:dayOfWeek", "description": "The property \"time:dayOfWeek\" has no explicitly defined characteristics or super-properties. Its domain is restricted to instances of \"time:DateTimeDescription\", indicating it is used to associate a date-time description with its corresponding day of the week. No specific range or inverse property is defined."}
{"class": "time:year", "description": "The property \"time:year\" has no specified characteristics or super-properties. Its domain is restricted to instances of time:DateTimeDescription, but no range is defined. This property is intended to associate a DateTimeDescription with a corresponding year value. No inverse property is specified."}
{"class": "time:days", "description": "The property \"time:days\" has no specified characteristics, super-properties, or inverse properties. Its domain is restricted to \"time:DurationDescription\", indicating that it is used to associate a duration description with an unspecified value representing days. The range of this property is not explicitly defined."}
{"class": "time:intervalMeets", "description": "The property \"time:intervalMeets\" has no specified property characteristics or super-properties. Its domain is restricted to instances of \"time:ProperInterval\", indicating that it is used to relate proper time intervals to other entities. No range or inverse property is defined."}
{"class": "time:week", "description": "The property \"time:week\" has no explicitly defined characteristics, super-properties, or inverse properties. Its domain is restricted to instances of \"time:DateTimeDescription,\" indicating that it is used to associate a week-related value or resource with a date-time description. No range is specified."}
{"class": "time:intervalBefore", "description": "The property \"time:intervalBefore\" has no explicitly defined characteristics or domain restrictions. Its range is restricted to \"time:ProperInterval,\" indicating that it relates an entity to a proper time interval. It is specified as a sub-property of \"time:before,\" inheriting its semantic implications. No inverse property is specified."}
{"class": "time:before", "description": "The property \"time:before\" is a transitive property used to relate temporal entities, as indicated by its range restriction to \"time:TemporalEntity.\" There are no explicit domain constraints, no specified super-properties, and no defined inverse property. This property is typically used to assert that one temporal entity precedes another in time."}
{"class": "time:inside", "description": "The property \"time:inside\" has no specified characteristics, domain, super-properties, or inverse properties. Its range is restricted to instances of \"time:Instant\", indicating that it relates subjects to a specific temporal instant."}
{"class": "time:intervalFinishes", "description": "The property \"time:intervalFinishes\" has no specified characteristics or domain restrictions. Its range is limited to instances of \"time:ProperInterval,\" indicating it relates an entity to a proper time interval that it finishes. There are no super-properties or inverse properties defined."}
{"class": "time:day", "description": "The property \"time:day\" has no special characteristics or super-properties. Its domain is restricted to instances of \"time:DateTimeDescription,\" indicating that it is used to associate a day value with a temporal description. There are no specified range constraints or inverse properties."}
{"class": "Palmtree", "description": "Palmtree is defined as a subclass of plant and is characterized by a structural restriction: every palmtree has at least one part that is not a branch. This axiom formally distinguishes palmtrees from other plants by specifying that some of their parts must differ from branches."}
{"class": "Xylem", "description": "xylem is defined as a subclass of PlantParts. This means that every instance of xylem is considered a plant part, inheriting all characteristics common to plant parts. No additional property restrictions or disjointness axioms are specified for this class."}
{"class": "Omnivore", "description": "Omnivore is defined as a subclass of animal, and is explicitly disjoint from carnivore, meaning an individual cannot be both an omnivore and a carnivore. An individual is classified as an omnivore if and only if it consumes some animal matter, some plant matter, and some food that is a part of either an animal or a plant. This class captures organisms with a diet that includes both animal and plant sources, as well as foods derived from any part of animals or plants."}
{"class": "giraffe", "description": "giraffe is defined as a subclass of animal, where members of this class are characterized by a strict dietary restriction: they eat only twigs or leaves, with no other types of food permitted. This formalization ensures that any individual classified as a giraffe must have an exclusively twig- or leaf-based diet."}
{"class": "PlantParts", "description": "PlantParts is a subclass of owl:Thing, representing entities that are considered parts of plants. There are no additional property restrictions or disjointness axioms specified for this class."}
{"class": "eaten-by", "description": "The property \"eaten-by\" has no specified characteristics, domain, range, super-properties, or inverse properties. This indicates that there are no explicit restrictions or relationships defined for this property in the ontology."}
{"class": "AmericanHot", "description": "AmericanHot is a subclass of NamedPizza, defined uniquely by its combination of toppings and origin. It is explicitly disjoint from a variety of other specific pizzas, meaning an individual pizza cannot simultaneously belong to AmericanHot and any of those disjoint classes. \n\nEvery AmericanHot pizza must have as toppings at least one of each: HotGreenPepperTopping, JalapenoPepperTopping, TomatoTopping, PeperoniSausageTopping, and MozzarellaTopping. The pizza must also have its country of origin specified as America. Additionally, the only allowable toppings on an AmericanHot pizza are MozzarellaTopping, PeperoniSausageTopping, JalapenoPepperTopping, TomatoTopping, or HotGreenPepperTopping—no additional topping types are permitted. \n\nThese axioms ensure AmericanHot is a distinct, well-defined pizza variety with specific ingredient and classification requirements."}
{"class": "Caprina", "description": "Caprina is defined as a subclass of NamedPizza and is explicitly disjoint from a range of other pizzas, ensuring that no individual can simultaneously be classified as Caprina and any of the listed pizzas (such as LaReine, Margherita, or FourSeasons). Caprina pizzas are characterized by specific topping requirements: they must include at least some TomatoTopping, SundriedTomatoTopping, MozzarellaTopping, and GoatsCheeseTopping, and are restricted to having only MozzarellaTopping, TomatoTopping, SundriedTomatoTopping, or GoatsCheeseTopping as toppings—no other toppings are permitted. This formalization ensures that any pizza classified as Caprina features this unique and exclusive combination of toppings."}
{"class": "FruttiDiMare", "description": "FruttiDiMare is a subclass of NamedPizza, representing a specific pizza variety. It is explicitly disjoint with a range of other pizzas, ensuring that an individual pizza cannot simultaneously be a FruttiDiMare and any of the listed disjoint pizzas (e.g., Mushroom, Margherita, Capricciosa). A FruttiDiMare pizza is characterized by its toppings: it must have at least some TomatoTopping, GarlicTopping, and MixedSeafoodTopping, and all its toppings are restricted to being either GarlicTopping, TomatoTopping, or MixedSeafoodTopping (no other toppings are permitted). This definition formalizes FruttiDiMare pizzas as a distinct seafood pizza with a strict combination of garlic, tomato, and mixed seafood as its exclusive toppings."}
{"class": "Margherita", "description": "Margherita is defined as a subclass of NamedPizza, explicitly disjoint with various other named pizzas such as Mushroom, LaReine, and AmericanHot—ensuring that no individual pizza can simultaneously be classified as Margherita and any of those disjoint pizzas. Every Margherita must have at least one tomato topping and at least one mozzarella topping, and may have only mozzarella or tomato toppings (no other toppings are permitted). This formalization precisely characterizes Margherita pizzas by the exclusivity of their ingredients and distinguishes them from other named pizza varieties."}
{"class": "Parmense", "description": "Parmense is defined as a subclass of NamedPizza and is explicitly disjoint from a wide range of other pizza types, ensuring that no individual pizza can simultaneously belong to Parmense and any of the disjoint classes. Members of Parmense must have at least one topping each of tomato, ham, parmesan, mozzarella, and asparagus. Additionally, Parmense pizzas are restricted to only having mozzarella, tomato, ham, parmesan, or asparagus as toppings, with no other topping types permitted. This precisely delineates Parmense based on its unique combination of required and allowed toppings."}
{"class": "QuattroFormaggi", "description": "QuattroFormaggi is defined as a subclass of NamedPizza, and is explicitly disjoint with a comprehensive list of other pizza varieties (including Mushroom, LaReine, Napoletana, and others), ensuring that no pizza can belong to both QuattroFormaggi and any of those classes simultaneously. A QuattroFormaggi pizza is required to have at least one topping of TomatoTopping and at least one topping of FourCheesesTopping, and is restricted to having only TomatoTopping or FourCheesesTopping as toppings, with no additional varieties permitted. This formalization ensures that QuattroFormaggi uniquely represents a pizza distinguished by its combination of tomato and four-cheese toppings, and by its mutual exclusivity with other named pizzas."}
{"class": "SloppyGiuseppe", "description": "SloppyGiuseppe is defined as a subclass of NamedPizza and is disjoint with a range of other specific pizza classes, ensuring that no individual pizza can simultaneously belong to these classes and SloppyGiuseppe. Members of the SloppyGiuseppe class are characterized by the mandatory presence of HotSpicedBeefTopping, TomatoTopping, GreenPepperTopping, MozzarellaTopping, and OnionTopping. Furthermore, SloppyGiuseppe pizzas are restricted to have only these toppings, meaning no other types of toppings are permitted. This formalization precisely specifies both the unique composition and distinct identity of SloppyGiuseppe within the named pizza hierarchy."}
{"class": "Veneziana", "description": "Veneziana is a subclass of NamedPizza, representing a specific type of pizza originating from Italy. It is explicitly disjoint with a list of other named pizzas, ensuring that no pizza can simultaneously be classified as Veneziana and any of those pizzas.\n\nMembers of the Veneziana class are characterized by having only the following toppings: MozzarellaTopping, TomatoTopping, SultanaTopping, OnionTopping, CaperTopping, OliveTopping, and PineKernels. Furthermore, every Veneziana pizza must have at least one instance of each of the following toppings: PineKernels, TomatoTopping, OliveTopping, SultanaTopping, MozzarellaTopping, OnionTopping, and CaperTopping. Additionally, the country of origin for Veneziana pizzas is required to be Italy. This formalization ensures that any pizza classified as Veneziana strictly follows this combination of toppings and origin."}
{"class": "MixedSeafoodTopping", "description": "MixedSeafoodTopping is defined as a subclass of FishTopping, indicating it inherits all characteristics of fish-based toppings. It is explicitly disjoint with AnchoviesTopping, meaning no individual topping can be both a MixedSeafoodTopping and an AnchoviesTopping. This ensures that a MixedSeafoodTopping never consists solely of anchovies and represents a distinct category of seafood toppings."}
{"class": "CaperTopping", "description": "CaperTopping is defined as a subclass of VegetableTopping, indicating it is a type of vegetable-based topping. It is disjoint with other specific vegetable toppings such as RocketTopping, OnionTopping, SpinachTopping, GarlicTopping, ArtichokeTopping, PepperTopping, AsparagusTopping, OliveTopping, MushroomTopping, PetitPoisTopping, and TomatoTopping, ensuring that an individual cannot simultaneously belong to CaperTopping and any of these classes. Additionally, every CaperTopping is characterized by having at least some level of mild spiciness, as specified by the property restriction (hasSpiciness some Mild)."}
{"class": "LeekTopping", "description": "LeekTopping is defined as a subclass of VegetableTopping, and it is explicitly disjoint from a number of other vegetable-based toppings, including RocketTopping, OnionTopping, SpinachTopping, GarlicTopping, ArtichokeTopping, PepperTopping, AsparagusTopping, OliveTopping, CaperTopping, PetitPoisTopping, and TomatoTopping—ensuring no individual can simultaneously belong to both LeekTopping and any of these classes. Additionally, every LeekTopping individual is characterized by having some level of mild spiciness, as specified by the restriction (hasSpiciness some Mild)."}
{"class": "OnionTopping", "description": "OnionTopping is defined as a subclass of VegetableTopping and is explicitly disjoint with LeekTopping, SpinachTopping, GarlicTopping, ArtichokeTopping, PepperTopping, AsparagusTopping, OliveTopping, CaperTopping, MushroomTopping, PetitPoisTopping, and TomatoTopping, meaning no individual can be an instance of OnionTopping and any of those classes simultaneously. Members of this class are characterized by having at least medium spiciness, as specified by the restriction that they must have some level of spiciness classified as medium."}
{"class": "RocketTopping", "description": "RocketTopping is defined as a subclass of VegetableTopping, representing toppings derived from rocket (arugula). It is explicitly disjoint with other specified vegetable toppings such as LeekTopping, OnionTopping, SpinachTopping, GarlicTopping, ArtichokeTopping, PepperTopping, AsparagusTopping, OliveTopping, CaperTopping, MushroomTopping, and PetitPoisTopping, ensuring that no topping can belong to RocketTopping and any of these classes simultaneously. Additionally, every RocketTopping is characterized by having at least some medium level of spiciness, as specified by the property restriction [hasSpiciness some Medium]."}
{"class": "CajunSpiceTopping", "description": "CajunSpiceTopping is defined as a subclass of HerbSpiceTopping, meaning it inherits all characteristics of herb and spice-based toppings. Additionally, every instance of CajunSpiceTopping is required to have at least some level of hot spiciness, as specified by the restriction “hasSpiciness some Hot.” No explicit disjointness with other classes is asserted. This formalization ensures that all members of CajunSpiceTopping are distinguished by their hot spiciness."}
{"class": "FishTopping", "description": "FishTopping is defined as a subclass of PizzaTopping and is explicitly disjoint with SauceTopping, VegetableTopping, CheeseTopping, HerbSpiceTopping, NutTopping, and FruitTopping, meaning no individual can belong to both FishTopping and any of these other topping types. Members of this class are characterized by having at least some level of mild spiciness, as specified by the property restriction [hasSpiciness some Mild]. This ensures that any FishTopping must exhibit mild spiciness and belongs exclusively within the category of pizza toppings derived from fish."}
{"class": "HerbSpiceTopping", "description": "HerbSpiceTopping is defined as a subclass of PizzaTopping, representing a category of pizza toppings that consist exclusively of herbs and spices. It is explicitly disjoint from MeatTopping, SauceTopping, VegetableTopping, CheeseTopping, NutTopping, and FruitTopping, ensuring that any individual topping classified under HerbSpiceTopping cannot simultaneously belong to any of these other topping categories. This formalization distinguishes herb and spice-based toppings from other common pizza topping groups."}
{"class": "SauceTopping", "description": "SauceTopping is defined as a subclass of PizzaTopping, representing a specific type of topping used on pizzas. It is explicitly disjoint with MeatTopping, VegetableTopping, CheeseTopping, HerbSpiceTopping, NutTopping, and FruitTopping, ensuring that no individual can simultaneously belong to SauceTopping and to any of these other topping categories. This formalization distinguishes sauce-based pizza toppings as a unique class, separate from other major topping types."}
{"class": "GorgonzolaTopping", "description": "GorgonzolaTopping is a subclass of CheeseTopping, explicitly disjoint with GoatsCheeseTopping, ParmesanTopping, and FourCheesesTopping—ensuring no individual can belong to more than one of these classes simultaneously. Members of GorgonzolaTopping are characterized by having at least one association with mild spiciness through the hasSpiciness property. This formal definition ensures that any GorgonzolaTopping is a unique cheese topping distinguished by its mild spiciness."}
{"class": "ChickenTopping", "description": "ChickenTopping is defined as a subclass of MeatTopping, and is explicitly disjoint with PeperoniSausageTopping and HotSpicedBeefTopping—no individual can be classified as both ChickenTopping and either of those two classes. Any instance of ChickenTopping is restricted to having at least some level of mild spiciness through the hasSpiciness property. This ensures that ChickenTopping represents a unique, meat-based pizza topping that is distinctly mild and never overlaps with pepperoni sausage or hot spiced beef varieties."}
{"class": "PeperoniSausageTopping", "description": "PeperoniSausageTopping is a subclass of MeatTopping, indicating it is a type of meat-based topping. It is explicitly disjoint from HamTopping and ChickenTopping, ensuring that no individual topping can simultaneously be classified as PeperoniSausageTopping and either of those classes. Members of this class are characterized by having at least medium spiciness, as specified by the property restriction hasSpiciness some Medium."}
{"class": "ThinAndCrispyBase", "description": "ThinAndCrispyBase is defined as a subclass of PizzaBase, indicating that every instance of ThinAndCrispyBase is a type of PizzaBase. There are no explicit disjointness axioms specified, so ThinAndCrispyBase may overlap with other subclasses of PizzaBase unless otherwise stated. This class formalization is used to categorize pizza bases characterized by their thin and crispy texture within the pizza ontology."}
{"class": "SweetPepperTopping", "description": "SweetPepperTopping is defined as a subclass of PepperTopping and is explicitly disjoint from both GreenPepperTopping and PeperonataTopping, ensuring that no individual can simultaneously be a member of these classes. All individuals of SweetPepperTopping must have at least some degree of mild spiciness, as indicated by the property restriction [hasSpiciness some Mild]. This class formalizes toppings characterized by their mild flavor profile and distinct identity from other pepper-based toppings."}
{"class": "Medium", "description": "Medium is defined as a subclass of Spiciness, representing a specific level of spiciness distinct from other categories. It is explicitly disjoint with Mild, ensuring that no individual can be both Medium and Mild in terms of spiciness. This class is intended to categorize items that possess a moderate degree of spiciness, neither mild nor another spiciness subclass."}
{"class": "Pizza", "description": "Pizza is defined as a subclass of Food, meaning it inherits all characteristics of food items. It is explicitly disjoint from both IceCream and PizzaBase, so no individual can simultaneously be an instance of Pizza and either of those classes. Additionally, every Pizza must have at least one base that is an instance of PizzaBase, ensuring that all pizzas are characterized by the presence of a suitable base."}
{"class": "PizzaTopping", "description": "PizzaTopping is defined as a subclass of Food, indicating it is a type of food item. It is explicitly disjoint with both Pizza and PizzaBase, ensuring that no individual can simultaneously be classified as a PizzaTopping and a Pizza or a PizzaBase. This formalization means PizzaTopping represents ingredients added to pizzas, distinct from the pizza itself and its base."}
{"class": "Spiciness", "description": "Spiciness is defined as a subclass of ValuePartition, indicating that it functions as a categorical partitioning of possible values within a specific context (such as levels of spiciness in foods). As a value partition, it is used to organize and distinguish instances by assigning them to discrete, mutually exclusive categories related to spiciness."}
{"class": "VegetarianPizza", "description": "VegetarianPizza is formally defined as any Pizza that does not have any MeatTopping or FishTopping as a topping. This means that VegetarianPizza is equivalent to the class of Pizzas lacking both meat-based and fish-based toppings; individuals in this class may have other types of toppings but must explicitly exclude all meat and fish toppings. There are no explicit disjointness restrictions with other classes."}
{"class": "hasSpiciness", "description": "The property \"hasSpiciness\" is defined as a Functional property, meaning each subject can have at most one value for this property. No explicit domain or range is specified. It does not have any super-properties or inverse properties."}
{"class": "hasIngredient", "description": "The property \"hasIngredient\" is defined as a transitive property, meaning if a food item A hasIngredient B and B hasIngredient C, then A hasIngredient C. Both its domain and range are restricted to the class \"Food\", indicating that this property relates food items to their component food ingredients. It does not have any specified super-properties or inverse properties."}
{"class": "hasTopping", "description": "The property \"hasTopping\" is defined as an inverse functional property, meaning each pizza topping is related to at most one pizza through this property. Its domain is restricted to \"Pizza\" and its range to \"PizzaTopping,\" indicating it links pizzas to their toppings. \"hasTopping\" is a sub-property of \"hasIngredient,\" specifying that toppings are a particular kind of ingredient. No inverse property is specified."}
{"class": "isIngredientOf", "description": "The property \"isIngredientOf\" is a transitive object property with both its domain and range restricted to the class \"Food.\" This means that if a food item is an ingredient of another, and that item is itself an ingredient of a third food, the first is considered an ingredient of the third. No super-properties or inverse properties are specified."}
{"class": "Protein-ligand docking", "description": "Protein-ligand docking is defined as a subclass of molecular docking, characterizing computational or experimental procedures in which the output must include at least one protein-ligand complex. This formalization ensures that any instance of protein-ligand docking results in the generation or identification of a protein-ligand complex."}
{"class": "MLInterfaces", "description": "MLInterfaces is defined as a subclass of software, specifically characterized by its role in facilitating interactions between data and machine learning algorithms. Instances of MLInterfaces must accept as input gene expression datasets (with an associated data format specification) and must output either ALL or AML datasets (also with a defined data format specification). Additionally, all MLInterfaces are required to be implemented in the R programming language, formally ensuring compatibility with R-based computational workflows."}
{"class": "Microsoft Excel 2007", "description": "Microsoft Excel 2007 is a subclass of Microsoft Excel, characterized by its support for both input and output of data in multiple formats: it is capable of importing data in tab-delimited file format and XLS spreadsheet format, and outputting data in XLS spreadsheet and XML spreadsheet formats. The release date is specified as ns1:00, and its official homepage is http://office.microsoft.com/. This version is directly succeeded by Microsoft Excel for Windows 2010 and has the version identifier \"Microsoft 2007 version.\""}
{"class": "GeneSelector", "description": "GeneSelector is defined as a subclass of software, characterized by its ability to implement a variety of statistical and computational methods. Specifically, any instance of GeneSelector must implement at least one of the following techniques: SAM, BaldiLongT, FoxDimmicT, WilcEbam, Bayesian Model, Wilcoxon, Linear modelling, or t-test. This formalization ensures that GeneSelector software is equipped to perform gene selection using multiple analytical approaches."}
{"class": "Pathway ID (ConsensusPathDB)", "description": "Pathway ID (ConsensusPathDB) is defined as a subclass of ConsensusPathDB identifier. This means any instance of Pathway ID (ConsensusPathDB) is recognized as a type of unique identifier specifically used within the ConsensusPathDB resource, dedicated to identifying biological pathways recorded in this database."}
{"class": "Transcriptomics", "description": "Transcriptomics is defined as a subclass of Genomics. It represents a specialized area within Genomics, specifically focused on the study and characterization of the transcriptome—all RNA transcripts produced by the genome—of a given organism or cell type. This formalization positions Transcriptomics as a distinct but related domain under the broader field of Genomics."}
{"class": "'beadarraySNP'", "description": "beadarraySNP is a class characterized by a combination of specific property restrictions: it requires at least some specified data input in the form of a text data set and produces at least some specified data output in the form of a graph plot. Instances of beadarraySNP are executed within the context of data normalization processes and are encoded using the R programming language. No additional subclass or disjointness axioms are currently specified for this class."}
{"class": "MEDME", "description": "MEDME is a class defined by the following characteristics: it processes at least one specified data input that is a data object, with the explicit requirement that the input conforms to the R data frame format. It produces at least one specified data output that is a data object formatted according to the GFF specification. Furthermore, any instance of MEDME must be encoded in the R programming language."}
{"class": "Splice site prediction", "description": "Splice site prediction is a class characterized by the property that it is associated with at least one topic related to gene structure. There are no specified superclasses or disjoint classes, but the presence of the property restriction \"[has topic some Gene structure]\" ensures that any instance of Splice site prediction must be concerned with or related to the structure of genes."}
{"class": "Functional enrichment", "description": "Functional enrichment is a subclass of both gene expression data analysis and enrichment, indicating it involves methods that analyze gene expression data to identify statistically significant overrepresentation of biological functions, pathways, or categories within a gene set. This establishes functional enrichment as a specialized approach within broader enrichment analyses, specifically applied in the context of gene expression studies."}
{"class": "Acuity", "description": "Acuity is defined as any entity that is the output of at least one software publishing process in which Molecular Devices is a participant. This specification restricts class membership to outputs directly associated with publishing activities involving Molecular Devices, ensuring that only entities linked to such processes are included."}
{"class": "Raw microarray data", "description": "Raw microarray data is defined as a subclass of experimental measurement, meaning it represents a specific type of data obtained directly from experimental procedures involving microarrays. All individuals classified as raw microarray data are, by definition, also considered experimental measurements."}
{"class": "Protein structure prediction", "description": "Protein structure prediction is a subclass of Protein analysis, Prediction and recognition (protein), Protein sequence analysis, and Structure prediction. \nThis class is characterized by processes or activities that generate a Protein structure as output and are explicitly focused on the topic of Protein structure prediction. \nMembers of this class are methods or approaches dedicated to predicting the three-dimensional structure of proteins based on sequence or related information."}
{"class": "Protein interaction network comparison", "description": "Protein interaction network comparison is defined as a subclass of Protein function comparison. This means that every instance of Protein interaction network comparison is also considered an instance of Protein function comparison. The class specifically focuses on comparing networks of interactions between proteins, as a subdomain of the broader context of comparing protein functions."}
{"class": "timecourse", "description": "timecourse is defined as a subclass of software, specifically characterized by implementing some form of Robust Multi-array Average (RMA) methodology. Instances of this class are published by Bioconductor, are encoded in the R programming language, and are restricted to producing data output that has a format specification only in the CEL binary format. This formalization ensures that any timecourse software must fulfill these requirements and cannot represent software lacking these key attributes."}
{"class": "sizepower", "description": "sizepower is defined as a subclass of software that is executed in the context of background correction, data normalization, and differential expression analysis. It requires input data in the form of an R data frame and produces output data also as an R data frame, as specified by its format restrictions. Furthermore, sizepower is published exclusively by Bioconductor, ensuring its provenance and association with this software repository."}
{"class": "derivative software not allowed", "description": "derivative software not allowed is defined as a subclass of Derivatives clause, indicating it represents a specific kind of clause that addresses the restriction or prohibition of creating derivative software. This class does not have any explicitly declared disjointness with other classes."}
{"class": "logitT", "description": "logitT is defined as a subclass of software that implements both the Logit-t algorithm and the t-test. It is used specifically in differential expression analysis and requires as input data with a format specified exclusively as either CEL binary format or CEL ASCII format. The output produced by logitT is an R data frame. Additionally, all instances of logitT are published by Bioconductor."}
{"class": "MPL v2.0", "description": "MPL v2.0 is defined as a subclass of MPL (Mozilla Public License) and is characterized by its compatibility: it is a license that is compatible with at least some instances of the GNU GPL v3 license. This axiom ensures that any license categorized as MPL v2.0 must be able to coexist or interact legally with GNU GPL v3 in some licensing scenarios."}
{"class": "BAR", "description": "BAR is defined as a subclass of Binary format. This indicates that every instance of BAR is also an instance of Binary format, inheriting all characteristics and constraints of the Binary format class. No additional property restrictions or disjointness axioms are specified for BAR."}
{"class": "affyPara", "description": "affyPara is defined as a subclass of software, specifically published by Bioconductor. It is executed in computational processes that perform averaging, correction, and data normalization. Its specified data input must be in the CEL binary format or CEL ASCII format. The data outputs are either graph plots or R data frames, with the latter characterized by an explicit format specification. This ontological definition formalizes affyPara as specialized software for processing microarray data within the defined formats and computational contexts."}
{"class": "vsn", "description": "vsn is defined as a subclass of software, characterized by its capability to process gene expression datasets as specified data input. Any instance of vsn must satisfy the property restrictions that it is executed in processes involving correction, data normalization, and differential expression analysis. This formalization ensures all vsn instances are specialized software tools for gene expression data processing workflows."}
{"class": "SAGx", "description": "SAGx is defined as a subclass of software, specifically characterized by several formal restrictions: it is published exclusively by Bioconductor, accepts as data input graph plots that are specified only in the R data frame format, and is implemented in the R programming language. These constraints ensure that any instance of SAGx software must originate from Bioconductor, be capable of processing graph plot data provided as R data frames, and be encoded in R."}
{"class": "phyloXML", "description": "phyloXML is defined as a subclass of Phylogenetic tree format (XML), indicating that it is a specific type of XML-based format used for representing phylogenetic trees. Any instance of phyloXML is also considered an instance of Phylogenetic tree format (XML)."}
{"class": "matlab software", "description": "matlab software is defined as any entity that is encoded in some MATLAB language. This equivalence axiom specifies that membership in the class is strictly determined by being software that is written using MATLAB language."}
{"class": "Epitope mapping", "description": "Epitope mapping is defined as a subclass of protein sequence feature detection, focusing on the identification and analysis of epitopes. It is characterized by having a topical relationship to immunology, meaning that any instance of epitope mapping must relate to immunological topics. This ensures that the process specifically pertains to immunological research or applications within the broader domain of protein sequence analysis."}
{"class": "Algorithms for Calculating Microarray Enrichment", "description": "Algorithms for Calculating Microarray Enrichment is defined as a subclass of software. Instances of this class must accept input data that is both classified as data and specified in the format of an R data frame. They are encoded in the R programming language and implement both the Algorithms for Calculating Microarray Enrichment procedure and the Chi-square algorithm. This ensures that each member of the class provides functionality for microarray enrichment analysis using Chi-square methodologies, specifically within the R environment and with structured R data frame input."}
{"class": "dhf", "description": "dhf is defined as a subclass of Textual format, meaning every instance of dhf is necessarily a textual format and inherits all characteristics of textual formats."}
{"class": "affyTiling", "description": "affyTiling is defined as a subclass of software. It is characterized by the following formal restrictions: it is published by Bioconductor; it is encoded in the R language; and it is executed in tasks involving correction and data normalization. affyTiling specifically outputs data in the form of CSV data sets. For data input, it requires files with a format specification limited exclusively to BPMAP or CEL binary formats. These axioms precisely describe the technical requirements and functional context of affyTiling within data analysis workflows."}
{"class": "RLMM", "description": "RLMM is defined as a subclass of software, characterized by the following constraints: it requires input data in the form of Xba.CQV, Xba.regions, and .raw files, with these formats explicitly specified. Its output is some type of graph plot. RLMM is implemented in the R programming language, is involved in data normalization processes, and is published via the Bioconductor platform. These axioms formally specify RLMM’s role, operational context, and technical details within data analysis workflows."}
{"class": "Restriction map", "description": "Restriction map is defined as a subclass of Sequence map, meaning every restriction map is also a sequence map. This hierarchical relationship indicates that all properties and characteristics of sequence maps are inherited by restriction maps, while restriction maps may possess additional distinguishing features not shared with general sequence maps."}
{"class": "Organism name", "description": "Organism name is defined as a subclass of Name, indicating that every organism name is a specialized form of name. This relationship ensures that only valid names applicable to organisms are included in this class."}
{"class": "Medline Display Format", "description": "Medline Display Format is defined as a subclass of Textual format, indicating that it represents a specific kind of textual format used for displaying information, likely in the context of Medline bibliographic data. All individuals in this class inherit the general properties and characteristics of textual formats."}
{"class": "Codon usage table ID", "description": "Codon usage table ID is defined as an entity that serves as an identifier for at least one Genetic code as well as for at least one Codon usage table. It is formally constrained such that every instance of Codon usage table ID must be linked, via the 'is identifier of' property, to a Genetic code and to a Codon usage table."}
{"class": "vbmp", "description": "vbmp is a subclass of software, characterized by implementing Multinomial probit regression with Gaussian Process priors. It is specifically encoded in the R language, and is published by Bioconductor. vbmp requires as input data an R data frame (with mandatory format specification), and produces outputs that include both a graph plot and an R data frame (again with explicit format specification). These axioms formally constrain vbmp to operate within the R ecosystem, handle structured data in R data frame format, and utilize advanced regression methods, ensuring proper interoperability and reproducibility within computational biology workflows."}
{"class": "Structure prediction", "description": "Structure prediction is a subclass of both Prediction and recognition and Structure analysis. It is defined by having at least one output that is a Structure and is associated with topics related to structure prediction. Any instance of Structure prediction must produce some Structure as an output and must concern topics involving structure prediction."}
{"class": "bigWig", "description": "bigWig is defined as a subclass of Binary format, indicating that every instance of bigWig is a specific type of binary file format. This classification formally asserts that bigWig files inherit all characteristics common to binary formats."}
{"class": "Book ID", "description": "Book ID is defined as a subclass of Identifier (typed), indicating that any Book ID is a specialized form of typed identifier uniquely associated with books. This formalization ensures that Book ID inherits all characteristics and constraints of typed identifiers while being specifically applicable to the domain of books."}
{"class": "2bit", "description": "2bit is defined as a subclass of Raw sequence format, indicating that it is a specific type or specialization of raw sequence format used for representing biological sequence data. All individuals classified as 2bit inherently inherit the characteristics and constraints of Raw sequence format."}
{"class": "Structural variation", "description": "Structural variation is defined as a subclass of Chromosomes, indicating that every structural variation is considered a type of chromosome-related entity. This formalization positions structural variation within the broader context of chromosomal features or modifications."}
{"class": "MVCClass", "description": "MVCClass is defined as a subclass of software, characterized by several key property restrictions. It is executed within some data visualization context and is encoded in the R programming language. Additionally, it has a specified data input that must be data which possesses a format specification of an R data frame. This ensures that any instance of MVCClass operates in a data visualization setting, relies on R code, and accepts inputs specifically formatted as R data frames."}
{"class": "Enzyme kinetics data", "description": "Enzyme kinetics data is defined as a subclass of Reaction data, indicating that it specifically represents data related to the kinetic properties and behaviors of enzyme-catalyzed reactions and inherits all characteristics of general reaction data."}
{"class": "RFAM accession", "description": "RFAM accession is defined as a subclass of Accession, indicating that every RFAM accession is a specific type of accession with all the general properties of an accession. No additional constraints or distinguishing characteristics are provided beyond its subclass relationship."}
{"class": "Sequence motif format", "description": "Sequence motif format is defined as a class of entities that serve as formats specifically for some Sequence motif. Any instance of Sequence motif format must be the format of at least one Sequence motif; this is specified by the existential restriction on the \"is format of\" property. No additional subclass relationships or disjointness axioms are asserted."}
{"class": "RNA secondary structure visualisation", "description": "RNA secondary structure visualisation is defined as a subclass of both RNA secondary structure analysis and Visualisation. This means that it is a specialized activity or method that involves representing or illustrating the secondary structure of RNA for purposes of analysis, falling within both the broader domains of RNA analysis and visualization techniques. No additional property restrictions apply to this class."}
{"class": "InChI", "description": "InChI is defined as a subclass of Textual format, indicating that it represents a form of information expressed in textual or string-based representation. Any instance of InChI is necessarily also an instance of Textual format."}
{"class": "Reference map name (SWISS-2DPAGE)", "description": "Reference map name (SWISS-2DPAGE) is defined as a subclass of Gel ID. This means every instance of Reference map name (SWISS-2DPAGE) is also an instance of Gel ID, inheriting all its properties and characteristics."}
{"class": "Python 2.6", "description": "Python 2.6 is defined as a class whose members possess the property has version with the specific value \"Python version 2.6\". This ensures that any individual classified as Python 2.6 must be associated explicitly with version 2.6 of Python."}
{"class": "ChipReader 3.1", "description": "ChipReader 3.1 is defined as a class whose instances are outputs of at least one software publishing process, and every such process must have Bio-Rad Laboratories, Inc. as a participant. This axiom ensures that any individual categorized as ChipReader 3.1 originates from a software publishing process involving Bio-Rad Laboratories, Inc."}
{"class": "Phylogenetic tree distances calculation", "description": "Phylogenetic tree distances calculation is a class whose members are characterized by the property that they produce at least one output classified as Phylogenetic tree distances. This means any instance of this class is associated with generating or yielding results that measure distances between phylogenetic trees. No superclass is explicitly defined."}
{"class": "GIF", "description": "GIF is defined as a subclass of raster image format, meaning every GIF is a type of raster image format. This classification indicates that GIFs inherit all properties and characteristics associated with raster image formats."}
{"class": "Genetic code identifier", "description": "Genetic code identifier is a class whose members serve as identifiers for at least one Genetic code. Any instance of this class is defined by the fact that it identifies some Genetic code, establishing a reference or association to a Genetic code entity."}
{"class": "unambiguous sequence", "description": "unambiguous sequence is defined as a subclass of Raw sequence format, indicating that every unambiguous sequence is a type of Raw sequence format. This classification implies that an unambiguous sequence shares all properties and constraints of a Raw sequence format, but may be further specialized to represent sequences with a single, clear interpretation."}
{"class": "codata", "description": "codata is defined as a subclass of Textual format, meaning every codata is a type of textual format. This classification situates codata within the broader category of data formats that are primarily text-based in nature."}
{"class": "iHOP symbol", "description": "iHOP symbol is defined as a subclass of both Gene ID and Protein accession. This means that every iHOP symbol is simultaneously a Gene ID and a Protein accession, inheriting all characteristics and constraints of these two parent classes. This class serves to integrate identifiers that are valid in both gene and protein contexts within the ontology."}
{"class": "unambiguous pure rna sequence", "description": "unambiguous pure rna sequence is defined as a subclass of unambiguous pure. This means every unambiguous pure rna sequence inherits all characteristics of unambiguous pure, while further specializing the concept—typically to represent RNA sequences that contain only unambiguous (unmodified and clearly defined) nucleotide bases. No additional restrictions or disjointness axioms are specified."}
{"class": "HMMER profile alignment (sequences versus HMMs)", "description": "HMMER profile alignment (sequences versus HMMs) is defined as a subclass of Textual format, indicating that it is a type of data represented in text form, specifically used to document the alignment of biological sequences against Hidden Markov Models (HMMs). This classification ensures that any instance of HMMER profile alignment is recognized as a textual data format within relevant ontological structures."}
{"class": "Enzyme ID (BioCyc)", "description": "Enzyme ID (BioCyc) is defined as a subclass of BioCyc ID, meaning it represents a specialized identifier within the BioCyc database specifically assigned to enzymes. Every instance of Enzyme ID (BioCyc) is also an instance of BioCyc ID."}
{"class": "Protein-protein interaction prediction (from protein structure)", "description": "Protein-protein interaction prediction (from protein structure) is a subclass of both Protein feature detection and Protein-protein interaction prediction. This class represents predictive methods or mechanisms that determine possible interactions between proteins specifically by utilizing protein structural information, inheriting characteristics from both feature detection and interaction prediction domains."}
{"class": "Sequence checksum generation", "description": "Sequence checksum generation is defined as a subclass of Generation, with the additional restriction that it must have some input that is a Sequence. This specifies that any instance of Sequence checksum generation involves a process or activity categorized under Generation and necessarily requires a Sequence as its input."}
{"class": "'domainsignatures'", "description": "domainsignatures is defined as a subclass of software, specifically characterized by several property restrictions: it must implement some Gene-Set Enrichment Analysis, require as input some Gene list, and produce as output some Graph plot. Additionally, it is executed within the context of descriptive statistical calculation. This formalization ensures that any instance of domainsignatures must fulfill all these functional roles, distinguishing it from other types of software."}
{"class": "Clustal", "description": "Clustal is defined as a subclass of software. This means Clustal is formally categorized as a type of software application, without further specified property restrictions or distinguishing characteristics in the current axioms."}
{"class": "Sequence composition plot", "description": "Sequence composition plot is defined as a subclass of Plot, indicating that it inherits all the characteristics of Plot while representing a more specific concept. This class is intended for visualizations that depict the composition of sequences, such as nucleotide or amino acid frequencies, organized graphically."}
{"class": "newick", "description": "newick is defined as a subclass of Textual format. Members of this class represent data using a textual notation, specifically designed to encode information in text form. This formalization ensures that all newick instances are recognized as specific types of textual formats."}
{"class": "bigBed", "description": "bigBed is defined as a subclass of Sequence annotation track format, indicating that any individual classified as a bigBed is also recognized as a Sequence annotation track format. There are no additional constraints or distinguishing features specified by the current axiom."}
{"class": "ClustalW format", "description": "ClustalW format is defined as a subclass of Alignment format (text), indicating that it is a specific type of alignment file represented in a text-based format, used to store sequence alignments. This formalization ensures all ClustalW format instances are recognized as alignment formats expressed as text files."}
{"class": "Pathway ID (PharmGKB)", "description": "Pathway ID (PharmGKB) is defined as a subclass of PharmGKB ID, indicating that it is a specific type of identifier used within the PharmGKB resource, specifically for representing biological pathways. Any instance of Pathway ID (PharmGKB) is, by definition, also a PharmGKB ID."}
{"class": "'codelink'", "description": "codelink is defined as a subclass of software. Its members are characterized by having at least one specified data input that must be either an XML or a text data set. The data output is constrained such that at least one output must include both a text data set and a graph plot. Additionally, every codelink must be executed within processing contexts that perform background correction, data normalization, descriptive statistical calculations, and differential expression analysis. This formalization ensures that codelink instances are specialized software tools tailored for advanced data processing workflows involving specific input types, multifaceted outputs, and a sequence of bioinformatics analyses."}
{"class": "Sequence record format", "description": "Sequence record format is defined as a subclass of Format (typed), indicating that it inherits all characteristics of a typed format. There are no additional property restrictions specified for this class, so its definition is solely based on its classification as a type of Format (typed)."}
{"class": "Protein sequence (raw)", "description": "Protein sequence (raw) is defined as a subclass of Raw sequence, indicating that every protein sequence (raw) is a specific type of raw sequence. This classification implies that all characteristics and constraints of Raw sequence apply to Protein sequence (raw), but no additional axioms or distinguishing features are specified beyond this relationship."}
{"class": "is executed in", "description": "The property \"is executed in\" has no specified characteristics, domain, or super-properties. Its range is restricted to instances of \"information processing,\" meaning it is used to associate an entity with an \"information processing\" context in which it is executed. No inverse property is defined."}
{"class": "is version of", "description": "The property \"is version of\" has no explicitly defined characteristics, domain or range restrictions, super-properties, or inverse properties. It is used without constraints on the types of entities it relates."}
{"class": "has format specification", "description": "The property \"has format specification\" links individuals of the class \"information content entity\" to individuals of the class \"data format specification.\" It has no explicitly defined characteristics, super-properties, or inverse properties. This property is used to specify the data format that an information content entity conforms to."}
{"class": "is input of", "description": "The property \"is input of\" has no specified characteristics or super-properties. Its domain is restricted to entities classified as \"data,\" and its range is limited to \"information processing\" entities. This property is used to indicate that some data serves as input to an information processing activity. No inverse property is defined."}
{"class": "Recognition", "description": "Recognition is defined as a subclass of Observation, representing a specific type of observation process. It is further constrained such that any instance of Recognition must be provided only by either a Person or a ProcessingComponent, ensuring that the source of recognition events is always one of these two entities. This formalization distinguishes Recognition events from other Observations based on their permissible providers."}
{"class": "Result", "description": "Result is a class characterized by several property restrictions: each Result must be described by exactly one DaySummary or Problem, and may only describe these types. Each Result must be provided by exactly one entity, which can be either a Person or a ProcessingComponent, and may only be provided by these types. Furthermore, each Result must have exactly one reporting time, which must be an instance of time:Instant. Results may have plausibility metrics, represented only by values of type xsd:double. These restrictions ensure that every Result is uniquely linked to its source, time, and subject, reflecting precise and validated reporting."}
{"class": "MoodSummary", "description": "MoodSummary is a subclass of DaySummary, representing a summary of mood-related aspects for a particular day. It is characterized by exactly one stressLevel, which must be a literal value, exactly one numberOfSocialInteractions (an integer), some physicalHygiene information, and some involvementInDiscussion. This formalization ensures that each MoodSummary instance documents a single stress level and number of social interactions, and includes details on both physical hygiene and participation in discussions."}
{"class": "EatingSummary", "description": "EatingSummary is defined as a subclass of ADLSummary. Each instance of EatingSummary must be associated with exactly one eatingLocation, which is an event:Place, and exactly one eatingDuration, which is a time:DurationDescription. Furthermore, any eatingDuration specified must be an instance of time:DurationDescription, ensuring the exclusivity and precision of duration representation. This formalization guarantees that any EatingSummary records structured information about where and for precisely how long eating occurred."}
{"class": "exerciseStartTime", "description": "The property \"exerciseStartTime\" has no specified domain, range, super-properties, inverse properties, or declared characteristics. Its intended use is to represent the start time of an exercise, but the axiom does not constrain its applicable subjects or the type of values it relates to."}
{"class": "eatingDuration", "description": "The property \"eatingDuration\" has no defined domain or explicit characteristics. Its range is unspecified, allowing for flexible use. It is a sub-property of \"time:hasDurationDescription\", indicating it is used to relate an entity to a temporal duration specifically describing the length of an eating event. No inverse property is specified."}
{"class": "ExperimentalDiagnosisAssessment", "description": "ExperimentalDiagnosisAssessment is defined as a subclass of ExperimentalAssessment. This means every instance of ExperimentalDiagnosisAssessment is also an instance of ExperimentalAssessment. There are no additional property restrictions specified for this class. This class represents a specific type of experimental assessment that is focused on diagnostic evaluation within an experimental context."}
{"class": "CountingType", "description": "CountingType is defined as a subclass of Type. This indicates that every CountingType is necessarily a Type, inheriting all characteristics of Type, but there are no additional restrictions or distinguishing features specified for CountingType beyond this subclass relationship."}
{"class": "GenderType", "description": "GenderType is defined as a subclass of Type. This means that every instance of GenderType is also an instance of Type. No additional constraints or equivalence conditions are specified for this class."}
{"class": "DiagnosisAssessment", "description": "DiagnosisAssessment is defined as a subclass of ClinicalAssessment. Every instance of DiagnosisAssessment must be associated with exactly one clinical diagnosis, specified by the property restriction that it has exactly one value for hasClinicalDiagnosis, and that value must be of type DiagnosisType. This formalizes that each diagnosis assessment relates to one and only one diagnosis type."}
{"class": "CognitiveAbilitiesData", "description": "CognitiveAbilitiesData is a class defined by several property restrictions. Every instance must have exactly one status of type ActivityStatusType, exactly one repetitions value (which must be an rdfs:Literal), exactly one compliantInstructionsOrder value (which must be a boolean), and exactly one taskDuration (which must be an instance of time:DurationDescription). The status property may only point to ActivityStatusType, repetitions only to rdfs:Literal, compliantInstructionsOrder only to boolean values, and taskDuration only to time:DurationDescription. This formalization ensures strict data structure and type safety for information related to cognitive ability assessment data."}
{"class": "GaitData", "description": "GaitData is defined as a subclass of MeasuredData, representing data specifically related to gait analysis. Members of this class are characterized by exactly one value each for walkingSpeed, stepLength, dynamicBalance (all with values restricted to literals), and stoppingDisplacement (restricted to a boolean value). Additionally, walkingSpeedInstantaneous and dynamicBalance can only take literal values. This formalization ensures that each GaitData instance uniquely records these properties, providing a precise structure for representing gait measurements."}
{"class": "StressData", "description": "StressData is defined as a subclass of MeasuredData. Any individual of StressData is characterized by the property restriction that its stressLevel property may only take values that are rdfs:Literal (such as numbers or strings). This ensures that StressData captures measured data in which stress level is recorded exclusively as a literal value."}
{"class": "HealthyControlParticipant", "description": "HealthyControlParticipant is defined as a subclass of Person, representing individuals who are considered persons. There are no additional axioms or property restrictions specified, indicating that HealthyControlParticipant inherits all characteristics of Person without further differentiation or equivalence to other classes."}
{"class": "Person", "description": "Person is defined as a subclass of ns1:Person. Every individual belonging to this class is required to participate in at least one Protocol, and is also restricted such that they participate only in Protocol (no other types of participation are allowed). Additionally, each Person is associated with at least one ClinicalRecord, one ExperimentalRecord, and one DemographicCharacteristicsRecord via the hasRecord property. This formalization ensures that all Persons have these specific record types and exclusively participate in Protocols."}
{"class": "S3_DiscussionWithClinicianStep", "description": "S3_DiscussionWithClinicianStep is defined as a subclass of ProtocolStep. Every instance of this class necessarily involves exactly one S3_P1_DirectedExpressionTask, and may additionally involve an S3_P21_PictureDescriptionTask or another Task. The property restriction ensures that all tasks involved are limited to S3_P1_DirectedExpressionTask, S3_P21_PictureDescriptionTask, or other specified Task subclasses, reflecting a step that is structured around these specific clinical activities."}
{"class": "S1_P13_WalkingCountingBackwardsTask", "description": "S1_P13_WalkingCountingBackwardsTask is defined as a subclass of DirectedTask. Members of this class are exclusively associated with counting types of CountingType and are required to have at least some measured data of both LatencyData and GaitData. It also enforces that measured data for this task must only include data of the following types: GaitData, LatencyData, MoodVoiceData, or StressData. This formalization ensures that instances of this class involve directed walking while counting backwards, with behavioral and cognitive performance captured by relevant measured data."}
{"class": "S3_P1_DirectedExpressionTask", "description": "S3_P1_DirectedExpressionTask is defined as a subclass of DirectedDiscussionTask. Members of this class are characterized by the property that they are associated with at least some measuredData of type MoodVoiceData. This means that every S3_P1_DirectedExpressionTask instance involves collecting or utilizing mood-related voice data as part of the task."}
{"class": "ExperimentalAssessment", "description": "ExperimentalAssessment is a class that is characterized by a property restriction: every instance must have the hasScore property whose values are only rdfs:Literal (such as numbers, strings, or other literal data). This ensures that the assessment results are always represented as literal data types, capturing quantified or descriptive information relevant to the assessment process."}
{"class": "ProtocolStep", "description": "ProtocolStep is a class characterized by its involvement in at least one Task (via the involvesTask property), with the restriction that it can only be associated with individuals of type Task through this property. Each ProtocolStep is also formally constrained to have exactly one startTime, which must be of type time:Instant, and may have zero or more endTimes, but any endTime provided must also be of type time:Instant. These axioms ensure that every ProtocolStep is precisely linked to its temporal boundaries and the tasks it entails."}
{"class": "areasOfNoInterestExplored", "description": "The property \"areasOfNoInterestExplored\" has no defined characteristics, domain, range, super-properties, or inverse properties. This indicates it is a general property without specific constraints or hierarchical relationships in the ontology."}
{"class": "compliantInstructionsOrder", "description": "The property \"compliantInstructionsOrder\" has no explicitly defined characteristics, domain, range, super-properties, or inverse properties. Its purpose and constraints are unspecified according to the given axioms."}
{"class": "hasDualTaskScore", "description": "The property \"hasDualTaskScore\" has no explicitly defined characteristics, domain, or range restrictions. It is not specified as a sub-property of any other property and does not have an inverse property. Its usage and semantics are unrestricted by the given axioms."}
{"class": "hasExperimentalDiagnosis", "description": "The property \"hasExperimentalDiagnosis\" has no specified domain, range, characteristics, super-properties, or inverse properties. This indicates it is a general property with no formal restrictions on the types of entities it can relate or the values it can take."}
{"class": "stepLength", "description": "The property \"stepLength\" has no explicitly defined characteristics, domain, or range restrictions. It is not declared as a sub-property of any other property and has no specified inverse property. This suggests its usage is flexible and not limited to particular classes or value types within the ontology."}
